import e from"lodash";var t,n;!function(e){e.Setting="setting",e.Translation="translation",e.UI="ui",e.Feature="feature"}(t||(t={})),function(e){e.Setting="settings",e.Translation="translations",e.UI="ui",e.Feature="features"}(n||(n={}));const a={[t.Setting]:{plural:n.Setting,label:"Setting",labelPlural:"Settings",order:1},[t.Translation]:{plural:n.Translation,label:"Translation",labelPlural:"Translations",order:2},[t.UI]:{plural:n.UI,label:"UI",labelPlural:"UI",order:3},[t.Feature]:{plural:n.Feature,label:"Feature",labelPlural:"Features",order:4}},{assign:o,mapValues:r}=e,l=(e={})=>(e=r(e,()=>!0),o({nested:!1,categorized:!1,sort:!1},e)),{fromPairs:s,sortBy:i,toPairs:c}=e,u=e=>s(i(c(e),0)),{each:d,setWith:f}=e,b=e=>{const t={};return d(e,(e,n)=>{f(t,n,e,Object)}),t},{each:g,get:p}=e,h=(e,t={},n=null)=>{const o=l(t);let r=e;return o.sort&&(r=u(r)),o.categorized&&(r=((e,t=null)=>{const n={};return g(e,(e,a)=>{if(t){const{key:n,value:o}=t(a,e);n&&(a=n),o&&(e=o)}n[a]=e}),n})(r,e=>{const t=p(n,e);return t&&(e=`${a[t.category].plural}.${e}`),{key:e}})),o.nested?b(r):r},{each:y,has:m}=e,$=(e,t=null,n=!1)=>{const a={};return y(e,(e,o)=>{let r=m(e,"value")&&!n?e.value:e.default;if(t){const{key:n,value:a}=t(o,e);n&&(o=n),a&&(r=a)}a[o]=r}),a},v=(e,t={},n=!1)=>{const o=l(t),r=$(e,(e,t)=>({key:e=o.categorized?`${a[t.category].plural}.${e}`:e}),n);return o.nested?b(r):r},{differenceWith:w,each:k,fromPairs:C,has:I,isEqual:L,pickBy:F,toPairs:O}=e,P=(e,t)=>{const n=C(w(O(t),O(e),L)),a=F(n,(t,n)=>!I(e,n)),o=F(n,(t,n)=>I(e,n)),r=C(w(O(e),O(t),L));return{added:a,changed:o,removed:F(r,(e,n)=>!I(t,n))}},j=(e,t)=>{const n=P(e,t),a={};return k(n,(t,o)=>{k(n[o],(t,n)=>{a[n]={value:t,status:o,previous:e[n]}})}),a},E=()=>{const e=process.memoryUsage();let t="Memory Usage\n";for(let n in e)t+=`${n}: ${Math.round(e[n]/1024/1024*100)/100} MB\n`;console.log(t)},{assign:T,each:U,get:S,has:z,includes:V,isObject:W,kebabCase:x,last:q,mapKeys:D,mapValues:M,merge:R,set:A,size:B,split:K,startCase:N,unset:G}=e,Z=e=>"object"==typeof e&&"boolean"==typeof e.default?"switch":"input",H=(e,t,n=!1)=>{if(W(t)){if(!n&&!z(t,"default")&&!z(t,"inherit"))throw new Error(`Config "${e}" is missing a "default" value (or "inherit" reference).`)}else t={default:t};return t},J=(e,t,n={})=>{if(delete(t=H(e,t)).key,t.docLink){const e=`Documentation on this feature can be found <a href="${t.docLink}">here</a>.`;t.hint=t.hint?e+`<br>${t.hint}`:e,delete t.docLink}if(t.inherit){const e=`When left blank, inherits value from <code>${t.inherit}</code>.`;t.hint=t.hint?e+`<br>${t.hint}`:e}return T({default:null,type:Z(t),label:N(q(K(e,"."))),category:"setting"},t,n)},Q=(e,t={},n)=>(e=D(e,(e,t)=>S(e,"key",t)),M(e,(e,a)=>(n&&n(a,e),J(a,e,t)))),X=(e,t)=>T({label:N(q(K(e,"."))),order:0,toggleable:!1,description:null,rootKey:null},t),Y=(e,t)=>{const n={};return U(e,e=>{if(W(e)&&!z(e,"key"))throw new Error("Onboarder config missing key!");const a=W(e)?e.key:e;if(!z(t,a))throw new Error(`Onboarder defines key "${a}" which does not exist.`);n[a]=W(e)?T({},t[a],e):T({},t[a])}),n},_=(e,t)=>{const n={};return U(e,(e,a)=>{n[a]={label:e.label?e.label:N(a),configs:Y(e.configs,t)}}),n},ee=async({getComponents:e,getConfigs:t,getLabel:n,getName:a,getOnboarders:o,source:r})=>{const l=a?await a():r,s={name:l,label:n?await n():N(l)},i=e?await e():null;if(t){const e=Q(await t()),n=((e,t={})=>{const n={};let a=!1;return U(e,e=>{if("object"==typeof e&&z(e,"component")){if(!z(n,e.component)){let a={};if(z(t,e.component)){const{getOptions:n}=t[e.component];a=n?n():t[e.component]}n[e.component]=X(e.component,a)}}else a=!0}),a&&B(n)&&(n.unsorted=X("unsorted",{order:999})),n})(e,i);R(s,{configs:e,components:n})}else{let{components:e,configs:t}=(e=>{const t={},n=(e=>M(e,(e,t)=>{const{getOptions:n}=e;return X(t,n?n():null)}))(e);return U(e,(e,a)=>{const o=(e,o="setting")=>{let r={component:a};const l=((e,t,n="setting")=>{const a={group:{path:"groups"},tab:{path:"tabs"}},o=[],r=(e,t=null)=>{const n={};return U(e,(e,a)=>{if(e=H(a,e),t){const{config:o,key:r}=t(a,e);n[r]=o}else n[a]=e}),n},l=(e,t)=>r(t,(t,n)=>("object"==typeof n&&(n.visibleIf&&(n.visibleIf=`${e}.${n.visibleIf}`),n.longLabel=`${N(e)} ⇢ ${n.longLabel?n.longLabel:n.label?n.label:N(t)}`),{key:`${e}.${t}`,config:n})),s=(l,s,i,c=!0,u="group",d)=>(V(o,l)?console.warn(`"${l}" group already exists in "${n}"`):o.push(l),((n,o,r,l="group")=>{let s=a[l].path,i={};U(r,n=>{if("object"==typeof n&&n.group){const o=n.group;U(a,n=>{const a=S(e,[t,n.path,o]);if(a){A(i,[n.path,o],a),G(e,[t,n.path,o]);const r=S(e,[t,n.path],{});0===B(r)&&G(e,[t,n.path])}})}}),A(e,[t,s,n],T({label:o},i))})(l,s,i,u),r(i,(e,t)=>(t.group=t.group?`${l}.${t.group}`:l,d&&d(e,t),{key:c?`${l}.${e}`:e,config:t})));return{addNested:l,addFeature:(e,t,n,a=!1,o=!0)=>{if(z(n,"enabled"))throw new Error(`Feature "${e}" should not contain a property named "enabled".`);return n=T({enabled:H("enabled",a)},n),s(e,t,n,o,"group",(t,n)=>{"enabled"!==t&&"object"==typeof n&&A(n,"visibleIf",`${e}.enabled`)})},addGroup:s,addTab:(e,t)=>{const a=`${n}-${x(e)}`;return s(a,e,t,!1,"tab")},addField:(e,t)=>{let n={};const a=`${e}.isVisible`,o=N(e);let r=o;if(n.isVisible={default:!0,label:"Visible",longLabel:`${o} ⇢ Visible`,styleClasses:"col-md-2"},n.required={default:!1,label:"Required",longLabel:`${o} ⇢ Required`,visibleIf:a,styleClasses:"col-md-2"},n.disabled={default:!1,label:"Disabled",longLabel:`${o} ⇢ Disabled`,visibleIf:a,styleClasses:"col-md-2"},n.readonly={default:!1,label:"Readonly",longLabel:`${o} ⇢ Readonly`,visibleIf:a,styleClasses:"col-md-2"},n.hasAutoFocus={default:!1,label:"Autofocus",longLabel:`${o} ⇢ Autofocus`,visibleIf:a,styleClasses:"col-md-2"},n.pattern={default:"",label:"Pattern",longLabel:`${o} ⇢ Pattern`,visibleIf:a,styleClasses:"col-md-12"},t){const e=(e,t)=>{if(z(n,e))throw new Error(`Field ${e} already exists!`);const r=J(e,t,{visibleIf:a,styleClasses:"col-md-12"});r.longLabel=`${o} ⇢ ${r.label}`,n[e]=r},l=(e,t)=>{R(n[e],H(e,t,!0))},s=e=>{delete n[e]},i=e=>{r=e};t&&t({insert:e,modify:l,remove:s,modifyLabel:i})}return s(e,r,n,!0)},addPluralized:(e,t)=>{const n={};if(t.zero&&(n[0]={default:t.zero,label:"Zero Case",hint:"When there are 0 items"}),t.one&&(n[1]={default:t.one,label:"One Case",hint:"When there is 1 item"}),t.many&&(n.other={default:t.many,label:"Many Case",hint:"When there are many items"}),B(n))return l(e,n)}}})(n,a,o);o&&(r=T(r,{category:o}));const s=e(l);if(B(s)){const e=S(n,[a,"categories"],[]);e.push(o),A(n,[a,"categories"],e),((e,t,n)=>{R(e,((e,t,n)=>Q(t,n,t=>{if(z(e,t))throw new Error(`Duplicate key: "${t}"`)}))(e,t,n))})(t,s,r)}},{getConfigs:r,getFeatures:l,getSettings:s,getTranslations:i,getUI:c}=e;r?o(r):(s&&o(s,"setting"),i&&o(i,"translation"),c&&o(c,"ui"),l&&o(l,"feature"))}),{configs:t,components:n}})(i);R(s,{configs:t,components:e})}var c;return U(c=s.configs,(e,t)=>{if(e.inherit&&!z(c,e.inherit))throw new Error(`Config with key "${t}" has inherit property defined as "${e.inherit}" which is not a valid key!`)}),o&&(s.onboarders=((e,t)=>{const n={};return U(e,({getLabel:e,getTabs:a},o)=>{n[o]={label:e?e():N(o),tabs:a?_(a(),t):{}}}),n})(await o(),s.configs)),s};class te extends Error{constructor(e,t){super(`${t.message} ("${e}" source)`),this.name="SourceError"}}function ne(){return ne=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},ne.apply(this,arguments)}const ae=async(e,t)=>(await ee(ne({source:e},t))).configs;export{a as CATEGORIES,t as ConfigCategory,n as ConfigCategoryPlurals,te as SourceError,j as getDiff,P as getDiffByStatus,l as getTransformationOptions,E as logMemoryUsage,ee as parseSource,ae as parseSourceConfigs,u as sortObjectAlphabetically,$ as transformFromConfigsToResponse,h as transformResponse,v as transformToConfigValues,b as transformToNested};
//# sourceMappingURL=index.modern.js.map
