import e from"lodash";var t,n;!function(e){e.Setting="setting",e.Translation="translation",e.UI="ui",e.Feature="feature"}(t||(t={})),function(e){e.Setting="settings",e.Translation="translations",e.UI="ui",e.Feature="features"}(n||(n={}));const a={[t.Setting]:{plural:n.Setting,label:"Setting",labelPlural:"Settings",order:1},[t.Translation]:{plural:n.Translation,label:"Translation",labelPlural:"Translations",order:2},[t.UI]:{plural:n.UI,label:"UI",labelPlural:"UI",order:3},[t.Feature]:{plural:n.Feature,label:"Feature",labelPlural:"Features",order:4}},{assign:o,mapValues:r}=e,s=(e={})=>(e=r(e,()=>!0),o({nested:!1,categorized:!1,sort:!1},e)),{fromPairs:l,sortBy:i,toPairs:c}=e,u=e=>l(i(c(e),0)),{each:d,setWith:f}=e,g=e=>{const t={};return d(e,(e,n)=>{f(t,n,e,Object)}),t},{each:b,get:h}=e,p=(e,t={},n=null)=>{const o=s(t);let r=e;return o.sort&&(r=u(r)),o.categorized&&(r=((e,t=null)=>{const n={};return b(e,(e,a)=>{if(t){const{key:n,value:o}=t(a,e);n&&(a=n),o&&(e=o)}n[a]=e}),n})(r,e=>{const t=h(n,e);return t&&(e=`${a[t.category].plural}.${e}`),{key:e}})),o.nested?g(r):r},{each:y,get:m,has:$}=e,v=(e,t=null,n=!1)=>{const a={};return y(e,(o,r)=>{o.inherit&&(o.default=m(e,o.inherit).default);let s=$(o,"value")&&!n?o.value:o.default;if(t){const{key:e,value:n}=t(r,o);e&&(r=e),n&&(s=n)}a[r]=s}),a},w=(e,t={},n=!1)=>{const o=s(t),r=v(e,(e,t)=>({key:e=o.categorized?`${a[t.category].plural}.${e}`:e}),n);return o.nested?g(r):r},{differenceWith:k,each:C,fromPairs:I,has:L,isEqual:O,pickBy:F,toPairs:P}=e,j=(e,t)=>{const n=I(k(P(t),P(e),O)),a=F(n,(t,n)=>!L(e,n)),o=F(n,(t,n)=>L(e,n)),r=I(k(P(e),P(t),O));return{added:a,changed:o,removed:F(r,(e,n)=>!L(t,n))}},E=(e,t)=>{const n=j(e,t),a={};return C(n,(t,o)=>{C(n[o],(t,n)=>{a[n]={value:t,status:o,previous:e[n]}})}),a},T=()=>{const e=process.memoryUsage();let t="Memory Usage\n";for(let n in e)t+=`${n}: ${Math.round(e[n]/1024/1024*100)/100} MB\n`;console.log(t)},{assign:U,each:S,get:z,has:V,includes:W,isObject:x,kebabCase:q,last:D,mapKeys:M,mapValues:A,merge:B,set:K,size:N,split:R,startCase:G,unset:Z}=e,H=e=>"object"==typeof e&&"boolean"==typeof e.default?"switch":"input",J=(e,t,n=!1)=>{if(x(t)){if(!n&&!V(t,"default")&&!V(t,"inherit"))throw new Error(`Config "${e}" is missing a "default" value (or "inherit" reference).`)}else t={default:t};return t},Q=(e,t,n={})=>{if(delete(t=J(e,t)).key,t.docLink){const e=`Documentation on this feature can be found <a href="${t.docLink}">here</a>.`;t.hint=t.hint?e+`<br>${t.hint}`:e,delete t.docLink}if(t.inherit){const e=`When unchanged, inherits value from <code>${t.inherit}</code>.`;t.hint=t.hint?e+`<br>${t.hint}`:e}return U({default:null,type:H(t),label:G(D(R(e,"."))),category:"setting"},t,n)},X=(e,t={},n)=>(e=M(e,(e,t)=>z(e,"key",t)),A(e,(e,a)=>(n&&n(a,e),Q(a,e,t)))),Y=(e,t)=>U({label:G(D(R(e,"."))),order:0,toggleable:!1,description:null,rootKey:null},t),_=(e,t)=>{const n={};return S(e,e=>{if(x(e)&&!V(e,"key"))throw new Error("Onboarder config missing key!");const a=x(e)?e.key:e;if(!V(t,a))throw new Error(`Onboarder defines key "${a}" which does not exist.`);n[a]=x(e)?U({},t[a],e):U({},t[a])}),n},ee=(e,t)=>{const n={};return S(e,(e,a)=>{n[a]={label:e.label?e.label:G(a),configs:_(e.configs,t)}}),n},te=async({getComponents:e,getConfigs:t,getLabel:n,getName:a,getOnboarders:o,getOverrides:r,source:s})=>{const l=a?await a():s,i={name:l,label:n?await n():G(l)},c=e?await e():null;if(t){const e=X(await t()),n=((e,t={})=>{const n={};let a=!1;return S(e,e=>{if("object"==typeof e&&V(e,"component")){if(!V(n,e.component)){let a={};if(V(t,e.component)){const{getOptions:n}=t[e.component];a=n?n():t[e.component]}n[e.component]=Y(e.component,a)}}else a=!0}),a&&N(n)&&(n.unsorted=Y("unsorted",{order:999})),n})(e,c);B(i,{configs:e,components:n})}else{let{components:e,configs:t}=(e=>{const t={},n=(e=>A(e,(e,t)=>{const{getOptions:n}=e;return Y(t,n?n():null)}))(e);return S(e,(e,a)=>{const o=(e,o="setting")=>{let r={component:a};const s=((e,t,n="setting")=>{const a={group:{path:"groups"},tab:{path:"tabs"}},o=[],r=(e,t=null)=>{const n={};return S(e,(e,a)=>{if(e=J(a,e),t){const{config:o,key:r}=t(a,e);n[r]=o}else n[a]=e}),n},s=(e,t)=>r(t,(t,n)=>("object"==typeof n&&(n.visibleIf&&(n.visibleIf=`${e}.${n.visibleIf}`),n.longLabel=`${G(e)} ⇢ ${n.longLabel?n.longLabel:n.label?n.label:G(t)}`),{key:`${e}.${t}`,config:n})),l=(s,l,i,c=!0,u="group",d)=>(W(o,s)?console.warn(`"${s}" group already exists in "${n}"`):o.push(s),((n,o,r,s="group")=>{let l=a[s].path,i={};S(r,n=>{if("object"==typeof n&&n.group){const o=n.group;S(a,n=>{const a=z(e,[t,n.path,o]);if(a){K(i,[n.path,o],a),Z(e,[t,n.path,o]);const r=z(e,[t,n.path],{});0===N(r)&&Z(e,[t,n.path])}})}}),K(e,[t,l,n],U({label:o},i))})(s,l,i,u),r(i,(e,t)=>(t.group=t.group?`${s}.${t.group}`:s,d&&d(e,t),{key:c?`${s}.${e}`:e,config:t})));return{addNested:s,addFeature:(e,t,n,a=!1,o=!0)=>{if(V(n,"enabled"))throw new Error(`Feature "${e}" should not contain a property named "enabled".`);return n=U({enabled:J("enabled",a)},n),l(e,t,n,o,"group",(t,n)=>{"enabled"!==t&&"object"==typeof n&&K(n,"visibleIf",`${e}.enabled`)})},addGroup:l,addTab:(e,t)=>{const a=`${n}-${q(e)}`;return l(a,e,t,!1,"tab")},addField:(e,t)=>{let n={};const a=`${e}.isVisible`,o=G(e);let r=o;if(n.isVisible={default:!0,label:"Visible",longLabel:`${o} ⇢ Visible`,styleClasses:"col-md-2"},n.required={default:!1,label:"Required",longLabel:`${o} ⇢ Required`,visibleIf:a,styleClasses:"col-md-2"},n.disabled={default:!1,label:"Disabled",longLabel:`${o} ⇢ Disabled`,visibleIf:a,styleClasses:"col-md-2"},n.hasAutoFocus={default:!1,label:"Autofocus",longLabel:`${o} ⇢ Autofocus`,visibleIf:a,styleClasses:"col-md-2"},n.pattern={default:"",label:"Pattern",longLabel:`${o} ⇢ Pattern`,visibleIf:a,styleClasses:"col-md-12"},t){const e=(e,t)=>{if(V(n,e))throw new Error(`Field ${e} already exists!`);const r=Q(e,t,{visibleIf:a,styleClasses:"col-md-12"});r.longLabel=`${o} ⇢ ${r.label}`,n[e]=r},s=(e,t)=>{B(n[e],J(e,t,!0))},l=e=>{delete n[e]},i=e=>{r=e};t&&t({insert:e,modify:s,remove:l,modifyLabel:i})}return l(e,r,n,!0)},addPluralized:(e,t)=>{const n={};if(t.zero&&(n[0]={default:t.zero,label:"Zero Case",hint:"When there are 0 items"}),t.one&&(n[1]={default:t.one,label:"One Case",hint:"When there is 1 item"}),t.many&&(n.other={default:t.many,label:"Many Case",hint:"When there are many items"}),N(n))return s(e,n)}}})(n,a,o);o&&(r=U(r,{category:o}));const l=e(s);if(N(l)){const e=z(n,[a,"categories"],[]);e.push(o),K(n,[a,"categories"],e),((e,t,n)=>{B(e,((e,t,n)=>X(t,n,t=>{if(V(e,t))throw new Error(`Duplicate key: "${t}"`)}))(e,t,n))})(t,l,r)}},{getConfigs:r,getFeatures:s,getSettings:l,getTranslations:i,getUI:c}=e;r?o(r):(l&&o(l,"setting"),i&&o(i,"translation"),c&&o(c,"ui"),s&&o(s,"feature"))}),{configs:t,components:n}})(c);B(i,{configs:t,components:e})}var u;return S(u=i.configs,(e,t)=>{if(e.inherit&&!V(u,e.inherit))throw new Error(`Config with key "${t}" has inherit property defined as "${e.inherit}" which is not a valid key!`)}),o&&(i.onboarders=((e,t)=>{const n={};return S(e,({getLabel:e,getTabs:a},o)=>{n[o]={label:e?e():G(o),tabs:a?ee(a(),t):{}}}),n})(await o(),i.configs)),r&&(i.overrides=await r()),i};class ne extends Error{constructor(e,t){super(`${t.message} ("${e}" source)`),this.name="SourceError"}}function ae(){return ae=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},ae.apply(this,arguments)}const oe=async(e,t)=>(await te(ae({source:e},t))).configs;export{a as CATEGORIES,t as ConfigCategory,n as ConfigCategoryPlurals,ne as SourceError,E as getDiff,j as getDiffByStatus,s as getTransformationOptions,T as logMemoryUsage,te as parseSource,oe as parseSourceConfigs,u as sortObjectAlphabetically,v as transformFromConfigsToResponse,p as transformResponse,w as transformToConfigValues,g as transformToNested};
//# sourceMappingURL=index.modern.js.map
