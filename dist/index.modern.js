import e from"lodash";var t,n;!function(e){e.Setting="setting",e.Translation="translation",e.UI="ui",e.Feature="feature"}(t||(t={})),function(e){e.Setting="settings",e.Translation="translations",e.UI="ui",e.Feature="features"}(n||(n={}));const o={[t.Setting]:{plural:n.Setting,label:"Setting",labelPlural:"Settings",order:1},[t.Translation]:{plural:n.Translation,label:"Translation",labelPlural:"Translations",order:2},[t.UI]:{plural:n.UI,label:"UI",labelPlural:"UI",order:3},[t.Feature]:{plural:n.Feature,label:"Feature",labelPlural:"Features",order:4}},{assign:a,mapValues:r}=e,s=(e={})=>(e=r(e,()=>!0),a({nested:!1,categorized:!1,sort:!1},e)),{fromPairs:l,sortBy:i,toPairs:c}=e,u=e=>l(i(c(e),0)),{each:d,setWith:f}=e,g=e=>{const t={};return d(e,(e,n)=>{f(t,n,e,Object)}),t},{each:b,get:h}=e,p=(e,t={},n=null)=>{const a=s(t);let r=e;return a.sort&&(r=u(r)),a.categorized&&(r=((e,t=null)=>{const n={};return b(e,(e,o)=>{if(t){const{key:n,value:a}=t(o,e);n&&(o=n),a&&(e=a)}n[o]=e}),n})(r,e=>{const t=h(n,e);return t?e=`${o[t.category].plural}.${e}`:(console.warn(`Non-existent key ${e} is not part of the config set.`),e=`nonexistent.${e}`),{key:e}})),a.nested?g(r):r},{each:y,get:m,has:$}=e,w=(e,t=null,n=!1)=>{const o={};return y(e,(a,r)=>{a.inherit&&(a.default=m(e,a.inherit).default);let s=$(a,"value")&&!n?a.value:a.default;if(t){const{key:e,value:n}=t(r,a);e&&(r=e),n&&(s=n)}o[r]=s}),o},v=(e,t={},n=!1)=>{const a=s(t),r=w(e,(e,t)=>({key:e=a.categorized?`${o[t.category].plural}.${e}`:e}),n);return a.nested?g(r):r},{differenceWith:k,each:C,fromPairs:I,has:L,isEqual:O,pickBy:F,toPairs:P}=e,j=(e,t)=>{const n=I(k(P(t),P(e),O)),o=F(n,(t,n)=>!L(e,n)),a=F(n,(t,n)=>L(e,n)),r=I(k(P(e),P(t),O));return{added:o,changed:a,removed:F(r,(e,n)=>!L(t,n))}},E=(e,t)=>{const n=j(e,t),o={};return C(n,(t,a)=>{C(n[a],(t,n)=>{o[n]={value:t,status:a,previous:L(e,n)?e[n]:null}})}),o},T=()=>{const e=process.memoryUsage();let t="Memory Usage\n";for(let n in e)t+=`${n}: ${Math.round(e[n]/1024/1024*100)/100} MB\n`;console.log(t)},{assign:U,each:S,get:x,has:z,includes:V,isObject:W,kebabCase:q,last:D,mapKeys:M,mapValues:A,merge:B,set:N,size:K,split:R,startCase:G,unset:Z}=e,H=e=>"object"==typeof e&&"boolean"==typeof e.default?"switch":"input",J=(e,t,n=!1)=>{if(W(t)){if(!n&&!z(t,"default")&&!z(t,"inherit"))throw new Error(`Config "${e}" is missing a "default" value (or "inherit" reference).`)}else t={default:t};return t},Q=(e,t,n={})=>{if(delete(t=J(e,t)).key,t.docLink){const e=`Documentation on this feature can be found <a href="${t.docLink}">here</a>.`;t.hint=t.hint?e+`<br>${t.hint}`:e,delete t.docLink}if(t.inherit){const e=`When unchanged, inherits value from <code>${t.inherit}</code>.`;t.hint=t.hint?e+`<br>${t.hint}`:e}return U({default:null,type:H(t),label:G(D(R(e,"."))),category:"setting"},t,n)},X=(e,t={},n)=>(e=M(e,(e,t)=>x(e,"key",t)),A(e,(e,o)=>(n&&n(o,e),Q(o,e,t)))),Y=(e,t)=>U({label:G(D(R(e,"."))),order:0,toggleable:!1,description:null,rootKey:null},t),_=(e,t)=>{const n={};return S(e,e=>{if(W(e)&&!z(e,"key"))throw new Error("Onboarder config missing key!");const o=W(e)?e.key:e;if(!z(t,o))throw new Error(`Onboarder defines key "${o}" which does not exist.`);n[o]=W(e)?U({},t[o],e):U({},t[o])}),n},ee=(e,t)=>{const n={};return S(e,(e,o)=>{n[o]={label:e.label?e.label:G(o),configs:_(e.configs,t)}}),n},te=async({getComponents:e,getConfigs:t,getLabel:n,getName:o,getOnboarders:a,getOverrides:r,source:s})=>{const l=o?await o():s,i={name:l,label:n?await n():G(l)},c=e?await e():null;if(t){const e=X(await t()),n=((e,t={})=>{const n={};let o=!1;return S(e,e=>{if("object"==typeof e&&z(e,"component")){if(!z(n,e.component)){let o={};if(z(t,e.component)){const{getOptions:n}=t[e.component];o=n?n():t[e.component]}n[e.component]=Y(e.component,o)}}else o=!0}),o&&K(n)&&(n.unsorted=Y("unsorted",{order:999})),n})(e,c);B(i,{configs:e,components:n})}else{let{components:e,configs:t}=(e=>{const t={},n=(e=>A(e,(e,t)=>{const{getOptions:n}=e;return Y(t,n?n():null)}))(e);return S(e,(e,o)=>{const a=(e,a="setting")=>{let r={component:o};const s=((e,t,n="setting")=>{const o={group:{path:"groups"},tab:{path:"tabs"}},a=[],r=(e,t=null)=>{const n={};return S(e,(e,o)=>{if(e=J(o,e),t){const{config:a,key:r}=t(o,e);n[r]=a}else n[o]=e}),n},s=(e,t)=>r(t,(t,n)=>("object"==typeof n&&(n.visibleIf&&(n.visibleIf=`${e}.${n.visibleIf}`),n.longLabel=`${G(e)} ⇢ ${n.longLabel?n.longLabel:n.label?n.label:G(t)}`),{key:`${e}.${t}`,config:n})),l=(s,l,i,c=!0,u="group",d)=>(V(a,s)?console.warn(`"${s}" group already exists in "${n}"`):a.push(s),((n,a,r,s="group")=>{let l=o[s].path,i={};S(r,n=>{if("object"==typeof n&&n.group){const a=n.group;S(o,n=>{const o=x(e,[t,n.path,a]);if(o){N(i,[n.path,a],o),Z(e,[t,n.path,a]);const r=x(e,[t,n.path],{});0===K(r)&&Z(e,[t,n.path])}})}}),N(e,[t,l,n],U({label:a},i))})(s,l,i,u),r(i,(e,t)=>(t.group=t.group?`${s}.${t.group}`:s,d&&d(e,t),{key:c?`${s}.${e}`:e,config:t})));return{addNested:s,addFeature:(e,t,n,o=!1,a=!0)=>{if(z(n,"enabled"))throw new Error(`Feature "${e}" should not contain a property named "enabled".`);return n=U({enabled:J("enabled",o)},n),l(e,t,n,a,"group",(t,n)=>{"enabled"!==t&&"object"==typeof n&&N(n,"visibleIf",`${e}.enabled`)})},addGroup:l,addTab:(e,t)=>{const o=`${n}-${q(e)}`;return l(o,e,t,!1,"tab")},addField:(e,t)=>{let n={};const o=`${e}.isVisible`,a=G(e);let r=a;if(n.isVisible={default:!0,label:"Visible",longLabel:`${a} ⇢ Visible`,styleClasses:"col-md-2"},n.required={default:!1,label:"Required",longLabel:`${a} ⇢ Required`,visibleIf:o,styleClasses:"col-md-2"},n.disabled={default:!1,label:"Disabled",longLabel:`${a} ⇢ Disabled`,visibleIf:o,styleClasses:"col-md-2"},n.hasAutoFocus={default:!1,label:"Autofocus",longLabel:`${a} ⇢ Autofocus`,visibleIf:o,styleClasses:"col-md-2"},n.pattern={default:"",label:"Pattern",longLabel:`${a} ⇢ Pattern`,visibleIf:o,styleClasses:"col-md-12"},t){const e=(e,t)=>{if(z(n,e))throw new Error(`Field ${e} already exists!`);const r=Q(e,t,{visibleIf:o,styleClasses:"col-md-12"});r.longLabel=`${a} ⇢ ${r.label}`,n[e]=r},s=(e,t)=>{B(n[e],J(e,t,!0))},l=e=>{delete n[e]},i=e=>{r=e};t&&t({insert:e,modify:s,remove:l,modifyLabel:i})}return l(e,r,n,!0)},addPluralized:(e,t)=>{const n={};if(t.zero&&(n[0]={default:t.zero,label:"Zero Case",hint:"When there are 0 items"}),t.one&&(n[1]={default:t.one,label:"One Case",hint:"When there is 1 item"}),t.many&&(n.other={default:t.many,label:"Many Case",hint:"When there are many items"}),K(n))return s(e,n)}}})(n,o,a);a&&(r=U(r,{category:a}));const l=e(s);if(K(l)){const e=x(n,[o,"categories"],[]);e.push(a),N(n,[o,"categories"],e),((e,t,n)=>{B(e,((e,t,n)=>X(t,n,t=>{if(z(e,t))throw new Error(`Duplicate key: "${t}"`)}))(e,t,n))})(t,l,r)}},{getConfigs:r,getFeatures:s,getSettings:l,getTranslations:i,getUI:c}=e;r?a(r):(l&&a(l,"setting"),i&&a(i,"translation"),c&&a(c,"ui"),s&&a(s,"feature"))}),{configs:t,components:n}})(c);B(i,{configs:t,components:e})}var u;return S(u=i.configs,(e,t)=>{if(e.inherit&&!z(u,e.inherit))throw new Error(`Config with key "${t}" has inherit property defined as "${e.inherit}" which is not a valid key!`)}),a&&(i.onboarders=((e,t)=>{const n={};return S(e,({getLabel:e,getTabs:o},a)=>{n[a]={label:e?e():G(a),tabs:o?ee(o(),t):{}}}),n})(await a(),i.configs)),r&&(i.overrides=await r()),i};class ne extends Error{constructor(e,t){super(`${t.message} ("${e}" source)`),this.name="SourceError"}}function oe(){return oe=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},oe.apply(this,arguments)}const ae=async(e,t)=>(await te(oe({source:e},t))).configs;export{o as CATEGORIES,t as ConfigCategory,n as ConfigCategoryPlurals,ne as SourceError,E as getDiff,j as getDiffByStatus,s as getTransformationOptions,T as logMemoryUsage,te as parseSource,ae as parseSourceConfigs,u as sortObjectAlphabetically,w as transformFromConfigsToResponse,p as transformResponse,v as transformToConfigValues,g as transformToNested};
//# sourceMappingURL=index.modern.js.map
