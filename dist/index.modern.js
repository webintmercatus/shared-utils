import e from"lodash";var t,n;!function(e){e.Setting="setting",e.Translation="translation",e.UI="ui",e.Feature="feature"}(t||(t={})),function(e){e.Setting="settings",e.Translation="translations",e.UI="ui",e.Feature="features"}(n||(n={}));const o={[t.Setting]:{plural:n.Setting,label:"Setting",labelPlural:"Settings",order:1},[t.Translation]:{plural:n.Translation,label:"Translation",labelPlural:"Translations",order:2},[t.UI]:{plural:n.UI,label:"UI",labelPlural:"UI",order:3},[t.Feature]:{plural:n.Feature,label:"Feature",labelPlural:"Features",order:4}},{assign:a,mapValues:s}=e,r=(e={})=>(e=s(e,()=>!0),a({nested:!1,categorized:!1,sort:!1},e)),{fromPairs:l,sortBy:i,toPairs:c}=e,u=e=>l(i(c(e),0)),{each:d,setWith:f}=e,g=e=>{const t={};return d(e,(e,n)=>{f(t,n,e,Object)}),t},{each:b,get:p}=e,h=(e,t={},n=null)=>{const a=r(t);let s=e;return a.sort&&(s=u(s)),a.categorized&&(s=((e,t=null)=>{const n={};return b(e,(e,o)=>{if(t){const{key:n,value:a}=t(o,e);n&&(o=n),a&&(e=a)}n[o]=e}),n})(s,e=>{const t=p(n,e);return t?e=`${o[t.category].plural}.${e}`:(console.warn(`Non-existent key ${e} is not part of the config set.`),e=`nonexistent.${e}`),{key:e}})),a.nested?g(s):s},{each:m,get:y,has:$}=e,w=(e,t=null,n=!1)=>{const o={};return m(e,(a,s)=>{a.inherit&&(a.default=y(e,a.inherit).default);let r=$(a,"value")&&!n?a.value:a.default;if(t){const{key:e,value:n}=t(s,a);e&&(s=e),n&&(r=n)}o[s]=r}),o},v=(e,t={},n=!1)=>{const a=r(t),s=w(e,(e,t)=>({key:e=a.categorized?`${o[t.category].plural}.${e}`:e}),n);return a.nested?g(s):s},{differenceWith:k,each:C,fromPairs:I,has:L,isEqual:O,pickBy:F,toPairs:P}=e,T=(e,t)=>{const n=I(k(P(t),P(e),O)),o=F(n,(t,n)=>!L(e,n)),a=F(n,(t,n)=>L(e,n)),s=I(k(P(e),P(t),O));return{added:o,changed:a,removed:F(s,(e,n)=>!L(t,n))}},j=(e,t)=>{const n=T(e,t),o={};return C(n,(t,a)=>{C(n[a],(t,n)=>{o[n]={value:t,status:a,previous:L(e,n)?e[n]:null}})}),o},E=()=>{const e=process.memoryUsage();let t="Memory Usage\n";for(let n in e)t+=`${n}: ${Math.round(e[n]/1024/1024*100)/100} MB\n`;console.log(t)},{assign:U,each:x,endsWith:S,get:z,has:M,includes:W,isObject:V,kebabCase:D,last:q,mapKeys:A,mapValues:B,merge:N,set:K,size:R,split:G,startCase:Z,unset:_}=e,H=e=>"boolean"==typeof e.default?"switch":"input",J=(e,t,n=!1)=>{if(V(t)){if(!n&&!M(t,"default")&&!M(t,"inherit"))throw new Error(`Config "${e}" is missing a "default" value (or "inherit" reference).`)}else t={default:t};return t},Q=(e,t,n={})=>{if(t=J(e,t),X(e,t),delete t.key,t.docLink){const e=`Documentation on this feature can be found <a href="${t.docLink}">here</a>.`;t.hint=t.hint?e+`<br>${t.hint}`:e,delete t.docLink}if(t.inherit){const e=`When unchanged, inherits value from <code>${t.inherit}</code>.`;t.hint=t.hint?e+`<br>${t.hint}`:e}const o={default:null,type:H(t),label:Z(q(G(e,"."))),category:"setting"};return U(o,t,n)},X=(e,t)=>{t.inputType||!S(e,"_id")&&!S(e,"ID")||""!==t.default&&null!==t.default&&W(["boolean","string"],typeof t.default)||console.warn(`To remove this warning, set the "inputType" on "${e}" to "number" if its value is meant to be parsed as a number ("text" otherwise)`)},Y=(e,t={},n)=>(e=A(e,(e,t)=>z(e,"key",t)),B(e,(e,o)=>(n&&n(o,e),Q(o,e,t)))),ee=(e,t)=>U({label:Z(q(G(e,"."))),order:0,toggleable:!1,description:null,rootKey:null},t),te=(e,t)=>{const n={};return x(e,e=>{if(V(e)&&!M(e,"key"))throw new Error("Onboarder config missing key!");const o=V(e)?e.key:e;if(!M(t,o))throw new Error(`Onboarder defines key "${o}" which does not exist.`);n[o]=V(e)?U({},t[o],e):U({},t[o])}),n},ne=(e,t)=>{const n={};return x(e,(e,o)=>{n[o]={label:e.label?e.label:Z(o),configs:te(e.configs,t)}}),n},oe=async({getComponents:e,getConfigs:t,getLabel:n,getMappings:o,getName:a,getOnboarders:s,getOverrides:r,source:l})=>{const i=a?await a():l,c={name:i,label:n?await n():Z(i)},u=e?await e():null;if(t){const e=Y(await t()),n=((e,t={})=>{const n={};let o=!1;return x(e,e=>{if("object"==typeof e&&M(e,"component")){if(!M(n,e.component)){let o={};if(M(t,e.component)){const{getOptions:n}=t[e.component];o=n?n():t[e.component]}n[e.component]=ee(e.component,o)}}else o=!0}),o&&R(n)&&(n.unsorted=ee("unsorted",{order:999})),n})(e,u);N(c,{configs:e,components:n})}else{let{components:e,configs:t}=(e=>{const t={},n=(e=>B(e,(e,t)=>{const{getOptions:n}=e;return ee(t,n?n():null)}))(e);return x(e,(e,o)=>{const a=(e,a="setting")=>{let s={component:o};const r=((e,t,n="setting")=>{const o={group:{path:"groups"},tab:{path:"tabs"}},a=[],s=(e,t=null)=>{const n={};return x(e,(e,o)=>{if(e=J(o,e),t){const{config:a,key:s}=t(o,e);n[s]=a}else n[o]=e}),n},r=(e,t)=>s(t,(t,n)=>("object"==typeof n&&(n.visibleIf&&(n.visibleIf=`${e}.${n.visibleIf}`),n.longLabel=`${Z(e)} ⇢ ${n.longLabel?n.longLabel:n.label?n.label:Z(t)}`),{key:`${e}.${t}`,config:n})),l=(n,r,l,i=!0,c="group",u)=>(W(a,n)||a.push(n),((n,a,s,r="group")=>{let l=o[r].path,i={};x(s,n=>{if("object"==typeof n&&n.group){const a=n.group;x(o,n=>{const o=z(e,[t,n.path,a]);if(o){K(i,[n.path,a],o),_(e,[t,n.path,a]);const s=z(e,[t,n.path],{});0===R(s)&&_(e,[t,n.path])}})}}),K(e,[t,l,n],U({label:a},i))})(n,r,l,c),s(l,(e,t)=>(t.group=t.group?`${n}.${t.group}`:n,u&&u(e,t),{key:i?`${n}.${e}`:e,config:t})));return{addNested:r,addFeature:(e,t,n,o=!1,a=!0)=>{if(M(n,"enabled"))throw new Error(`Feature "${e}" should not contain a property named "enabled".`);return n=U({enabled:J("enabled",o)},n),l(e,t,n,a,"group",(t,n)=>{"enabled"!==t&&"object"==typeof n&&K(n,"visibleIf",`${e}.enabled`)})},addGroup:l,addTab:(e,t)=>{const o=`${n}-${D(e)}`;return l(o,e,t,!1,"tab")},addField:(e,t)=>{let n={};const o=`${e}.isVisible`,a=Z(e);let s=a;if(n.isVisible={default:!0,label:"Visible",longLabel:`${a} ⇢ Visible`,styleClasses:"col-md-2"},n.required={default:!1,label:"Required",longLabel:`${a} ⇢ Required`,visibleIf:o,styleClasses:"col-md-2"},n.disabled={default:!1,label:"Disabled",longLabel:`${a} ⇢ Disabled`,visibleIf:o,styleClasses:"col-md-2"},n.hasAutoFocus={default:!1,label:"Autofocus",longLabel:`${a} ⇢ Autofocus`,visibleIf:o,styleClasses:"col-md-2"},n.pattern={default:"",label:"Pattern",longLabel:`${a} ⇢ Pattern`,visibleIf:o,styleClasses:"col-md-12"},t){const e=(e,t)=>{if(M(n,e))throw new Error(`Field ${e} already exists!`);const s=Q(e,t,{visibleIf:o,styleClasses:"col-md-12"});s.longLabel=`${a} ⇢ ${s.label}`,n[e]=s},r=(e,t)=>{N(n[e],J(e,t,!0))},l=e=>{delete n[e]},i=e=>{s=e};t&&t({insert:e,modify:r,remove:l,modifyLabel:i})}return l(e,s,n,!0)},addPluralized:(e,t)=>{const n={};if(t.zero&&(n[0]={default:t.zero,label:"Zero Case",hint:"When there are 0 items"}),t.one&&(n[1]={default:t.one,label:"One Case",hint:"When there is 1 item"}),t.many&&(n.other={default:t.many,label:"Many Case",hint:"When there are many items"}),R(n))return r(e,n)}}})(n,o,a);a&&(s=U(s,{category:a}));const l=e(r);if(R(l)){const e=z(n,[o,"categories"],[]);e.push(a),K(n,[o,"categories"],e),((e,t,n)=>{N(e,((e,t,n)=>Y(t,n,t=>{if(M(e,t))throw new Error(`Duplicate key: "${t}"`)}))(e,t,n))})(t,l,s)}},{getConfigs:s,getFeatures:r,getSettings:l,getTranslations:i,getUI:c}=e;s?a(s):(l&&a(l,"setting"),i&&a(i,"translation"),c&&a(c,"ui"),r&&a(r,"feature"))}),{configs:t,components:n}})(u);N(c,{configs:t,components:e})}var d;return x(d=c.configs,(e,t)=>{if(e.inherit&&!M(d,e.inherit))throw new Error(`Config with key "${t}" has inherit property defined as "${e.inherit}" which is not a valid key!`)}),s&&(c.onboarders=((e,t)=>{const n={};return x(e,({getLabel:e,getTabs:o},a)=>{n[a]={label:e?e():Z(a),tabs:o?ne(o(),t):{}}}),n})(await s(),c.configs)),r&&(c.overrides=await r()),o&&(c.mappings=await o()),c};class ae extends Error{constructor(e,t){super(`${t.message} ("${e}" source)`),this.name="SourceError"}}function se(){return se=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},se.apply(this,arguments)}const re=async(e,t)=>(await oe(se({source:e},t))).configs,{each:le,get:ie,includes:ce,isObject:ue,isUndefined:de}=e,fe=e=>{const t=(t,n,o=null)=>{const a=ie(e,[t,"configs",n]);o&&(ce(a.values,o)||console.warn(`Mapping Check: ${n} with option "${o}" does not exist on ${t}`)),de(a)&&console.warn(`Mapping Check: ${n} does not exist on ${t}`)};le(e,(e,n)=>{e.mappings&&le(e.mappings,(e,o)=>{le(e,(e,a)=>{ue(e)?le(e,(e,s)=>{t(n,a,s),t(o,e)}):(t(n,a),t(o,e))})})})};export{o as CATEGORIES,t as ConfigCategory,n as ConfigCategoryPlurals,ae as SourceError,j as getDiff,T as getDiffByStatus,r as getTransformationOptions,E as logMemoryUsage,oe as parseSource,re as parseSourceConfigs,u as sortObjectAlphabetically,w as transformFromConfigsToResponse,h as transformResponse,v as transformToConfigValues,g as transformToNested,fe as validateSources};
//# sourceMappingURL=index.modern.js.map
