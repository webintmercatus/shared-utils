{"version":3,"file":"index.cjs","sources":["../src/constants/CATEGORIES.ts","../src/fetchConfigs/transformationOptions.ts","../src/sortObjectAlphabetically.ts","../src/fetchConfigs/transformToNested.ts","../src/fetchConfigs/transformResponse.ts","../src/fetchConfigs/transformToConfigValues.ts","../src/getDiff.ts","../src/parseSource/parseSource.ts","../src/parseSource/validateSources.ts","../src/logMemoryUsage.ts","../src/parseSource/parseSourceConfigs.ts"],"sourcesContent":["/* eslint-disable no-unused-vars */\nexport enum ConfigCategory {\n  Setting = `setting`,\n  Translation = `translation`,\n  UI = `ui`,\n  Feature = `feature`\n}\n\nexport enum ConfigCategoryPlurals {\n  Setting = `settings`,\n  Translation = `translations`,\n  UI = `ui`,\n  Feature = `features`\n}\n\n/* eslint-enable: no-unused-vars */\nconst CATEGORIES = {\n  [ConfigCategory.Setting]: {\n    plural: ConfigCategoryPlurals.Setting,\n    label: `Setting`,\n    labelPlural: `Settings`,\n    order: 1,\n  },\n  [ConfigCategory.Translation]: {\n    plural: ConfigCategoryPlurals.Translation,\n    label: `Translation`,\n    labelPlural: `Translations`,\n    order: 2,\n  },\n  [ConfigCategory.UI]: {\n    plural: ConfigCategoryPlurals.UI,\n    label: `UI`,\n    labelPlural: `UI`,\n    order: 3,\n  },\n  [ConfigCategory.Feature]: {\n    plural: ConfigCategoryPlurals.Feature,\n    label: `Feature`,\n    labelPlural: `Features`,\n    order: 4,\n  },\n}\n\nexport { CATEGORIES }\n","import lodash from 'lodash'\n\nconst { assign, mapValues } = lodash\n\nexport type TransformationOptions = {\n  nested: boolean,\n  categorized: boolean,\n  sort: boolean,\n}\n\nconst getTransformationOptions = (options: Partial<TransformationOptions> = {}): TransformationOptions => {\n\n  options = mapValues(options, () => true)\n\n  const opts: TransformationOptions = {\n    nested: false,\n    categorized: false,\n    sort: false, // TODO: In EDGE, we may want to be more flexible and allow a string value for `sort` to support different sorting methods\n  }\n\n  return assign(opts, options)\n}\n\nexport { getTransformationOptions }\n","import lodash from 'lodash'\n\nconst { fromPairs, sortBy, toPairs } = lodash\n\nconst sortObjectAlphabetically = object => {\n  return fromPairs(sortBy(toPairs(object), 0)) as object\n}\n\nexport { sortObjectAlphabetically }\n","import lodash from 'lodash'\n\nconst { each, setWith } = lodash\n\nconst transformToNested = object => {\n\n  const transformed = {}\n\n  each(object, (value, key) => {\n    setWith(transformed, key, value, Object)\n  })\n\n  return transformed\n}\n\nexport { transformToNested }\n","import lodash from 'lodash'\n\nimport { CATEGORIES } from '../constants'\nimport { sortObjectAlphabetically } from '../sortObjectAlphabetically'\nimport { getTransformationOptions } from './transformationOptions'\nimport { transformToNested } from './transformToNested'\n\nconst { each, get } = lodash\n\nconst helpTransformResponse = (response, callback = null) => {\n\n  const transformed = {}\n\n  each(response, (value, key) => {\n\n    if (callback) {\n\n      const {\n        key: newKey,\n        value: newValue,\n      } = callback(key, value)\n\n      if (newKey) {\n        key = newKey\n      }\n\n      if (newValue) {\n        value = newValue\n      }\n    }\n\n    transformed[key] = value\n  })\n\n  return transformed\n}\n\nconst transformResponse = (response, opts = {}, configs = null) => {\n\n  const options = getTransformationOptions(opts)\n\n  let transformed = response\n\n  if (options.sort) {\n    transformed = sortObjectAlphabetically(transformed)\n  }\n\n  if (options.categorized) {\n\n    transformed = helpTransformResponse(transformed, key => {\n\n      const config = get(configs, key)\n\n      if (config) {\n        key = `${CATEGORIES[config.category].plural}.${key}`\n      } else {\n        console.warn(`Non-existent key ${key} is not part of the config set.`)\n        key = `nonexistent.${key}`\n      }\n\n      return {\n        key,\n      }\n    })\n  }\n\n  if (options.nested) {\n    return transformToNested(transformed)\n  }\n\n  return transformed\n}\n\nexport { transformResponse }\n","import lodash from 'lodash'\n\nimport { CATEGORIES } from '../constants'\nimport { getTransformationOptions } from './transformationOptions'\nimport { transformToNested } from './transformToNested'\n\nconst { each, get, has } = lodash\n\nconst transformFromConfigsToResponse = (configs, callback = null, defaultsOnly = false) => {\n\n  const response = {}\n\n  each(configs, (config, key) => {\n    // Set inherited values\n    if (config.inherit) {\n      config.default = get(configs, config.inherit).default\n    }\n    // TODO: Figure out why configs have value properties when a configuration is saved but not published\n    let value = has(config, `value`) && !defaultsOnly ? config.value : config.default\n\n    if (callback) {\n\n      const {\n        key: newKey,\n        value: newValue,\n      } = callback(key, config)\n\n      if (newKey) {\n        key = newKey\n      }\n\n      if (newValue) {\n        value = newValue\n      }\n    }\n\n    response[key] = value\n  })\n\n  return response\n}\n\nconst transformToConfigValues = (configs, opts = {}, defaultsOnly = false) => {\n\n  const options = getTransformationOptions(opts)\n\n  const response = transformFromConfigsToResponse(configs, (key, config) => {\n\n    key = options.categorized ? `${CATEGORIES[config.category].plural}.${key}` : key\n\n    return {\n      key,\n    }\n  }, defaultsOnly)\n\n  if (options.nested) {\n    return transformToNested(response)\n  }\n\n  return response\n}\n\nexport { transformFromConfigsToResponse, transformToConfigValues }\n","import lodash from 'lodash'\n\nconst { differenceWith, each, fromPairs, has, isEqual, pickBy, toPairs } = lodash\n\nconst getDiffByStatus = (object1, object2): object => {\n  const changes = fromPairs(differenceWith(toPairs(object2), toPairs(object1), isEqual)) as object\n\n  const added = pickBy(changes, (value, key) => {\n    return !has(object1, key)\n  })\n\n  const changed = pickBy(changes, (value, key) => {\n    return has(object1, key)\n  })\n\n  const reverseChanges = fromPairs(differenceWith(toPairs(object1), toPairs(object2), isEqual)) as object\n\n  const removed = pickBy(reverseChanges, (value, key) => {\n    return !has(object2, key)\n  })\n\n  return { added: added, changed: changed, removed: removed }\n}\n\nconst getDiff = (object1, object2) => {\n  const diffByStatus = getDiffByStatus(object1, object2)\n\n  const diff = {}\n\n  each(diffByStatus, (value, statusKey) => {\n    each(diffByStatus[statusKey], (value, key) => {\n      diff[key] = {\n        value: value,\n        status: statusKey,\n        previous: has(object1, key) ? object1[key] : null,\n      }\n    })\n  })\n\n  return diff\n}\n\nexport { getDiff, getDiffByStatus }\n","import lodash from 'lodash'\n\nimport type {\n  Component,\n  ComponentOptions,\n  Components, Config,\n  ConfigMappings,\n  ConfigObject,\n  Configs,\n  Onboarder,\n  Onboarders,\n  OnboarderTabs,\n  Source,\n  StandardizedConfigs,\n} from '../types'\n\nconst { assign, each, endsWith, get, has, includes, isObject, kebabCase, last, mapKeys, mapValues, merge, set, size, split, startCase, unset } = lodash\n\nexport type SourceConfigs = {\n  getComponents?: () => Promise<Components>,\n  getOverrides?: () => Promise<object>\n  getOnboarders?: () => Promise<Onboarder>,\n  getConfigs?: () => Promise<Configs>,\n  getMappings?: () => Promise<ConfigMappings>,\n  getLabel?: () => string | Promise<string | undefined>,\n  getName?: () => string | Promise<string | undefined>,\n  source?: string\n}\n\n// TODO: HelperFunctions is deprecated\nexport type HelperFunctions = ReturnType<typeof getHelpers>\nexport type Context = ReturnType<typeof getHelpers>\n\nexport type Definitions = {\n  [key: string]: DefinitionComponent\n}\n\n/* eslint-disable no-unused-vars */\nexport type DefinitionComponent = {\n  getConfigs?: (_: HelperFunctions) => Configs\n  getSettings?: (_: HelperFunctions) => Configs\n  getTranslations?: (_: HelperFunctions) => Configs\n  getUI?: (_: HelperFunctions) => Configs,\n  getFeatures?: (_: HelperFunctions) => Configs,\n  getOptions?: () => Component\n}\n\n/* eslint-enable no-unused-vars */\n\nconst getType = (config: ConfigObject) => {\n\n  switch (typeof config.default) {\n  case `boolean`:\n    return `switch`\n  }\n\n  return `input`\n}\n\nconst standardizeConfig = (key: string, config: Config, skipDefaultCheck = false) => {\n\n  if (isObject(config)) {\n    if (!skipDefaultCheck && (!has(config, `default`) && !has(config, `inherit`))) {\n      throw new Error(`Config \"${key}\" is missing a \"default\" value (or \"inherit\" reference).`)\n    }\n  } else {\n    config = {\n      default: config,\n    }\n  }\n\n  return config as ConfigObject\n}\n\nconst parseConfig = (key: string, config: Config, options: Partial<ConfigObject> = {}): ConfigObject => {\n\n  config = standardizeConfig(key, config)\n\n  logWarningsForConfigIfAny(key, config)\n\n  delete config.key\n\n  if (config.docLink) {\n    const docLinkText = `Documentation on this feature can be found <a href=\"${config.docLink}\">here</a>.`\n    config.hint = config.hint ? docLinkText + `<br>${config.hint}` : docLinkText\n    delete config.docLink\n  }\n\n  if (config.inherit) {\n    // TODO: It would be nice to eventually show the value of the config that is being inherited from\n    // as part of the message. (This would involve a DB lookup, so we'll save this for a later time.)\n    const inheritText = `When unchanged, inherits value from <code>${config.inherit}</code>.`\n    config.hint = config.hint ? inheritText + `<br>${config.hint}` : inheritText\n  }\n\n  const defaults = {\n    default: null, // This is placed here so that `default` appears as first property\n    type: getType(config),\n    label: startCase(last(split(key, `.`))),\n    category: `setting`,\n  } as ConfigObject\n\n  return assign(defaults, config, options)\n}\n\nconst logWarningsForConfigIfAny = (key: string, config: ConfigObject) => {\n\n  // This check will help to point out potential configs that should have their inputType set to \"number\"\n  if (!config.inputType && (endsWith(key, `_id`) || endsWith(key, `ID`))) {\n\n    // We can rule out a few cases with a couple of extra checks  \n    if (config.default === `` || config.default === null || !includes([`boolean`, `string`], typeof config.default)) {\n      console.warn(`To remove this warning, set the \"inputType\" on \"${key}\" to \"number\" if its value is meant to be parsed as a number (\"text\" otherwise)`)\n    }\n  }\n}\n\nconst parseConfigs = (\n  configs: Configs,\n  options: Partial<ConfigObject> = {},\n  // eslint-disable-next-line no-unused-vars\n  callback?: (key: string, config: Config) => void,\n) => {\n\n  configs = mapKeys(configs, (config: Config, key: string) => {\n    return get(config, `key`, key)\n  })\n\n  return mapValues(configs, (config: Config, key: string) => {\n\n    callback && callback(key, config)\n\n    return parseConfig(key, config, options)\n  }) as StandardizedConfigs\n}\n\nconst parseUniqueConfigs = (set: Configs, configs: Configs, options: Partial<ConfigObject>) => {\n  return parseConfigs(configs, options, (key) => {\n    if (has(set, key)) {\n      throw new Error(`Duplicate key: \"${key}\"`)\n    }\n  })\n}\n\nconst parseConfigsIntoCollection = (set: Configs, configs: Configs, options: Partial<ComponentOptions>) => {\n  merge(set, parseUniqueConfigs(set, configs, options))\n}\n\nconst getHelpers = (components: Components, component: string, helperType: string = `setting`) => {\n\n  const groupTypes = {\n    group: {\n      path: `groups`,\n    },\n    tab: {\n      path: `tabs`,\n    },\n  }\n\n  const trackedGroups = []\n\n  const walkConfigs = (configs: Configs, callback = null) => {\n\n    const walked = {}\n\n    each(configs, (config, key) => {\n      config = standardizeConfig(key, config)\n      if (callback) {\n        const {\n          config: newConfig,\n          key: newKey,\n        } = callback(key, config)\n        walked[newKey] = newConfig\n      } else {\n        walked[key] = config\n      }\n    })\n\n    return walked\n  }\n\n  const setComponentGroup = (name: string, label: string, configs: Configs, type = `group`) => {\n\n    let path: string = groupTypes[type].path\n    let replacement: ComponentOptions = {}\n\n    each(configs, config => {\n      if (typeof config === `object` && config.group) {\n\n        // TODO: This variable should handle cases where group value is deeply nested\n        const groupExpanded = config.group\n\n        each(groupTypes, groupType => {\n          const group = get(components, [component, groupType.path, groupExpanded])\n          if (group) {\n            set(replacement, [groupType.path, groupExpanded], group)\n            unset(components, [component, groupType.path, groupExpanded])\n\n            const holder = get(components, [component, groupType.path], {})\n            if (size(holder) === 0) {\n              unset(components, [component, groupType.path])\n            }\n          }\n        })\n      }\n    })\n\n    // TODO: Need to think about this more\n    // if (has(components, [component, path, name])) {\n    //   throw new Error(`Duplicate ${type}: \"${name}\"`)\n    // }\n\n    set(components, [component, path, name], assign({\n      label: label,\n    }, replacement))\n  }\n\n  const addNested = (name: string, configs: Configs) => {\n    return walkConfigs(configs, (key: string, config: Config) => {\n\n      if (typeof config === `object`) {\n        if (config.visibleIf) {\n          config.visibleIf = `${name}.${config.visibleIf}`\n        }\n\n        config.longLabel = `${startCase(name)} ⇢ ${config.longLabel ? config.longLabel : (config.label ? config.label : startCase(key))}`\n      }\n\n      return {\n        key: `${name}.${key}`,\n        config,\n      }\n    })\n  }\n\n  const addGroup = (\n    name: string,\n    label: string,\n    configs: Configs,\n    nesting = true,\n    type = `group`,\n    /* eslint-disable-next-line no-unused-vars */\n    callback?: (_: string, _2: Config) => void,\n  ) => {\n\n    // TODO: Eventually store a running list of problems so you can see a count of the issues\n    if (includes(trackedGroups, name)) {\n\n      // TODO: Investigate if this warning is still needed at all. What other parts of the config structure can be validated? \n      // console.warn(`\"${name}\" group already exists in \"${helperType}\"`)\n    } else {\n      trackedGroups.push(name)\n    }\n\n    setComponentGroup(name, label, configs, type)\n\n    return walkConfigs(configs, (key: string, config: ConfigObject) => {\n      config.group = config.group ? `${name}.${config.group}` : name\n\n      if (callback) {\n        callback(key, config)\n      }\n\n      return {\n        key: nesting ? `${name}.${key}` : key,\n        config,\n      }\n    })\n  }\n\n  const addFeature = (name: string, label: string, configs: Configs, enabled: boolean | Config = false, nesting = true) => {\n\n    if (has(configs, `enabled`)) {\n      throw new Error(`Feature \"${name}\" should not contain a property named \"enabled\".`)\n    }\n\n    configs = assign({\n      enabled: standardizeConfig(`enabled`, enabled),\n    }, configs)\n\n    configs = addGroup(name, label, configs, nesting, `group`, (key, config) => {\n      if (key !== `enabled`) {\n        typeof config === `object` && set(config, `visibleIf`, `${name}.enabled`)\n      }\n    })\n\n    return configs as StandardizedConfigs\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  type AddFieldCallbackInnerFuncType = (key: string, config: Config) => void\n  // eslint-disable-next-line no-unused-vars\n  type RemoveFieldCallbackInnerFuncType = (key: string) => void\n  // eslint-disable-next-line no-unused-vars\n  type ModifyLabelCallbackInnerFuncType = (key: string) => void\n\n  const addField = (\n    key: string,\n    // eslint-disable-next-line no-unused-vars\n    callback?: (arg: {\n      insert: AddFieldCallbackInnerFuncType,\n      modify: AddFieldCallbackInnerFuncType,\n      remove: RemoveFieldCallbackInnerFuncType,\n      modifyLabel: ModifyLabelCallbackInnerFuncType,\n    }) => void,\n  ) => {\n\n    let fields: Configs = {}\n\n    const visibleIf = `${key}.isVisible`\n\n    const prettyKey = startCase(key)\n\n    let label = prettyKey\n\n    fields.isVisible = {\n      default: true,\n      label: `Visible`,\n      longLabel: `${prettyKey} ⇢ Visible`,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.required = {\n      default: false,\n      label: `Required`,\n      longLabel: `${prettyKey} ⇢ Required`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.disabled = {\n      default: false,\n      label: `Disabled`,\n      longLabel: `${prettyKey} ⇢ Disabled`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.hasAutoFocus = {\n      default: false,\n      label: `Autofocus`,\n      longLabel: `${prettyKey} ⇢ Autofocus`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.pattern = {\n      default: ``,\n      label: `Pattern`,\n      longLabel: `${prettyKey} ⇢ Pattern`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-12`,\n    }\n\n    if (callback) {\n\n      const insert: AddFieldCallbackInnerFuncType = (key, config) => {\n\n        if (has(fields, key)) {\n          throw new Error(`Field ${key} already exists!`)\n        }\n\n        const parsedConfig = parseConfig(key, config, {\n          visibleIf: visibleIf,\n          styleClasses: `col-md-12`,\n        })\n\n        parsedConfig.longLabel = `${prettyKey} ⇢ ${parsedConfig.label}`\n\n        fields[key] = parsedConfig\n      }\n\n      const modify: AddFieldCallbackInnerFuncType = (key, config) => {\n        merge(fields[key], standardizeConfig(key, config, true))\n      }\n\n      const remove: RemoveFieldCallbackInnerFuncType = key => {\n        delete fields[key]\n      }\n\n      const modifyLabel: ModifyLabelCallbackInnerFuncType = newLabel => {\n        label = newLabel\n      }\n\n      callback && callback({\n        insert,\n        modify,\n        remove,\n        modifyLabel,\n      })\n    }\n\n    return addGroup(key, label, fields, true)\n  }\n\n  const addTab = (label: string, configs: Configs) => {\n\n    const name = `${helperType}-${kebabCase(label)}`\n\n    return addGroup(name, label, configs, false, `tab`)\n  }\n\n  type Pluralized = {\n    zero: string,\n    one: string,\n    many: string,\n  }\n\n  const addPluralized = (name: string, plurals: Pluralized) => {\n\n    const configs = {}\n\n    if (plurals.zero) {\n      configs[`0`] = {\n        default: plurals.zero,\n        label: `Zero Case`,\n        hint: `When there are 0 items`,\n      }\n    }\n\n    if (plurals.one) {\n      configs[`1`] = {\n        default: plurals.one,\n        label: `One Case`,\n        hint: `When there is 1 item`,\n      }\n    }\n\n    if (plurals.many) {\n      configs[`other`] = {\n        default: plurals.many,\n        label: `Many Case`,\n        hint: `When there are many items`,\n      }\n    }\n\n    if (size(configs)) {\n      return addNested(name, configs)\n    }\n  }\n\n  return {\n    addNested,\n    addFeature,\n    addGroup,\n    addTab,\n    addField,\n    addPluralized,\n  }\n}\n\nconst parseConfigsAndComponents = (definitions: Definitions) => {\n\n  const configs: Configs = {}\n  const components = parseComponents(definitions)\n\n  each(definitions, (component, key) => {\n\n    const helpParseConfigsWithCategory = (getCategoryFunction, category = `setting`) => {\n\n      let options: Partial<ConfigObject> = {\n        component: key,\n      }\n\n      const helpers = getHelpers(components, key, category)\n\n      if (category) {\n        options = assign(options, {\n          category: category,\n        })\n      }\n\n      const theseConfigs = getCategoryFunction(helpers)\n      if (size(theseConfigs)) {\n\n        const categories = get(components, [key, `categories`], [])\n        categories.push(category)\n        set(components, [key, `categories`], categories)\n\n        parseConfigsIntoCollection(configs, theseConfigs, options)\n      }\n    }\n\n    const {\n      getConfigs,\n      getFeatures,\n      getSettings,\n      getTranslations,\n      getUI,\n    } = component\n\n    if (getConfigs) {\n      helpParseConfigsWithCategory(getConfigs)\n    } else {\n\n      if (getSettings) {\n        helpParseConfigsWithCategory(getSettings, `setting`)\n      }\n\n      if (getTranslations) {\n        helpParseConfigsWithCategory(getTranslations, `translation`)\n      }\n\n      if (getUI) {\n        helpParseConfigsWithCategory(getUI, `ui`)\n      }\n\n      if (getFeatures) {\n        helpParseConfigsWithCategory(getFeatures, `feature`)\n      }\n    }\n  })\n\n  return {\n    configs,\n    components,\n  }\n}\n\nconst parseComponent = (key: string, component?: ComponentOptions) => {\n  return assign({\n    label: startCase(last(split(key, `.`))),\n    order: 0,\n    toggleable: false,\n    description: null,\n    rootKey: null,\n  }, component) as ComponentOptions\n}\n\nconst parseComponents = (components: Components) => {\n  return mapValues(components, (component, key: string) => {\n    const { getOptions } = component\n\n    return parseComponent(key, getOptions ? getOptions() : null)\n  }) as Components\n}\n\nconst parseComponentsFromConfigs = (configs: Configs, structure: Components = {}) => {\n\n  // TODO: Place all these types in the \"types\" directory\n  const components: Components = {}\n\n  let hasUnsorted = false\n\n  each(configs, config => {\n    if (typeof config === `object` && has(config, `component`)) {\n      if (!has(components, config.component)) {\n\n        let options = {}\n        if (has(structure, config.component)) {\n          const { getOptions } = structure[config.component]\n          options = getOptions ? getOptions() : structure[config.component]\n        }\n\n        components[config.component] = parseComponent(config.component, options)\n      }\n    } else {\n      hasUnsorted = true\n    }\n  })\n\n  if (hasUnsorted && size(components)) {\n    components.unsorted = parseComponent(`unsorted`, {\n      order: 999,\n    })\n  }\n\n  return components\n}\n\nconst standardizeConfigs = (configs: Configs, sourceConfigs): StandardizedConfigs => {\n\n  const standardizedConfigs = {}\n\n  each(configs, config => {\n\n    if (isObject(config) && !has(config, `key`)) {\n      throw new Error(`Onboarder config missing key!`)\n    }\n\n    const key: any = isObject(config) ? config.key : config\n\n    if (!has(sourceConfigs, key)) {\n      throw new Error(`Onboarder defines key \"${key}\" which does not exist.`)\n    }\n\n    if (isObject(config)) {\n      standardizedConfigs[key] = assign({}, sourceConfigs[key], config)\n    } else {\n      standardizedConfigs[key] = assign({}, sourceConfigs[key])\n    }\n  })\n\n  return standardizedConfigs\n}\n\nconst parseOnboarderTabs = (tabs, configs): OnboarderTabs => {\n\n  const parsedOnboardersTabs = {}\n\n  each(tabs, (tab, name) => {\n\n    parsedOnboardersTabs[name] = {\n      label: tab.label ? tab.label : startCase(name),\n      configs: standardizeConfigs(tab.configs, configs),\n    }\n  })\n\n  return parsedOnboardersTabs\n}\n\nconst parseOnboarders = (onboarders, configs): Onboarders => {\n\n  const parsedOnboarders = {}\n\n  each(onboarders, ({ getLabel, getTabs }, name) => {\n\n    parsedOnboarders[name] = {\n      label: getLabel ? getLabel() : startCase(name),\n      tabs: getTabs ? parseOnboarderTabs(getTabs(), configs) : {},\n    }\n  })\n\n  return parsedOnboarders\n}\n\nconst verifyConfigs = configs => {\n\n  each(configs, (config, key) => {\n\n    // Make sure \"inherit\" value exists as a key if defined\n    if (config.inherit) {\n\n      if (!has(configs, config.inherit)) {\n        throw new Error(`Config with key \"${key}\" has inherit property defined as \"${config.inherit}\" which is not a valid key!`)\n      }\n    }\n  })\n}\n\nconst parseSource = async ({ getComponents, getConfigs, getLabel, getMappings, getName, getOnboarders, getOverrides, source }: SourceConfigs) => {\n\n  const name = getName ? await getName() : source\n  const label = getLabel ? await getLabel() : startCase(name)\n\n  const options: Source = {\n    name,\n    label,\n  }\n\n  const grabComponents = getComponents ? await getComponents() : null\n\n  if (getConfigs) {\n    const configs = parseConfigs(await getConfigs())\n    const components = parseComponentsFromConfigs(configs, grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  } else {\n    let { components, configs } = parseConfigsAndComponents(grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  }\n\n  verifyConfigs(options.configs)\n\n  if (getOnboarders) {\n    options.onboarders = parseOnboarders(await getOnboarders(), options.configs)\n  }\n\n  if (getOverrides) {\n    options.overrides = await getOverrides()\n  }\n\n  if (getMappings) {\n    options.mappings = await getMappings()\n  }\n\n  return options\n}\n\nclass SourceError extends Error {\n\n  constructor(source, error) {\n    super(`${error.message} (\"${source}\" source)`)\n    this.name = `SourceError`\n  }\n}\n\nexport { parseSource, SourceError }\n","import lodash from 'lodash'\n\nconst { each, get, includes, isObject, isUndefined } = lodash\n\nconst validateSources = (sources) => {\n\n  const checkThatSourceHasConfig = (source, key: string, option: string = null) => {\n\n    const config = get(sources, [source, `configs`, key])\n\n    if (option) {\n      if (!includes(config.values, option)) {\n        console.warn(`Mapping Check: ${key} with option \"${option}\" does not exist on ${source}`)\n      }\n    }\n\n    if (isUndefined(config)) {\n      console.warn(`Mapping Check: ${key} does not exist on ${source}`)\n    }\n  }\n\n  each(sources, (source, key) => {\n\n    // Check 1: Verify that mapped keys exist\n    if (source.mappings) {\n      each(source.mappings, (mapping, mapTo) => {\n        each(mapping, (to, from) => {\n          if (isObject(to)) {\n            each(to, (valueTo, valueFrom) => {\n              // Object maps should already be set in \".values\" by the time we run this check here (eg. app/sources/wlw-v3/src/configs/components/order.ts)\n              checkThatSourceHasConfig(key, from, valueFrom)\n              checkThatSourceHasConfig(mapTo, valueTo)\n            })\n          } else {\n            checkThatSourceHasConfig(key, from)\n            checkThatSourceHasConfig(mapTo, to)\n          }\n        })\n      })\n    }\n\n  })\n}\n\nexport { validateSources }\n","const logMemoryUsage = () => {\n\n  const used = process.memoryUsage()\n\n  let message = `Memory Usage\\n`\n\n  for (let key in used) {\n    message += `${key}: ${Math.round(used[key] / 1024 / 1024 * 100) / 100} MB\\n`\n  }\n\n  console.log(message)\n}\n\nexport { logMemoryUsage }\n\n","import { parseSource, SourceConfigs } from './parseSource'\n\nconst parseSourceConfigs = async (source: string, stack: SourceConfigs) => {\n\n  const parsedSource = await parseSource({\n    source,\n    ...stack,\n  })\n\n  return parsedSource.configs\n}\n\nexport { parseSourceConfigs }\n"],"names":["_CATEGORIES","ConfigCategory","ConfigCategoryPlurals","CATEGORIES","Setting","plural","label","labelPlural","order","Translation","UI","Feature","assign","lodash","mapValues","getTransformationOptions","options","nested","categorized","sort","fromPairs","sortBy","toPairs","object","each","setWith","transformToNested","transformed","value","key","Object","get","has","transformFromConfigsToResponse","configs","callback","defaultsOnly","response","config","inherit","newKey","newValue","differenceWith","isEqual","pickBy","getDiffByStatus","object1","object2","changes","added","changed","removed","reverseChanges","endsWith","includes","isObject","kebabCase","last","mapKeys","merge","set","size","split","startCase","unset","standardizeConfig","skipDefaultCheck","Error","default","parseConfig","logWarningsForConfigIfAny","docLink","hint","docLinkText","inheritText","defaults","type","getType","category","inputType","console","warn","parseConfigs","parseComponent","component","toggleable","description","rootKey","standardizeConfigs","sourceConfigs","standardizedConfigs","parseOnboarderTabs","tabs","parsedOnboardersTabs","tab","name","parseSource","_ref2","getComponents","getConfigs","getLabel","getMappings","getName","getOnboarders","getOverrides","source","_temp9","_temp8","grabComponents","mappings","_temp","then","Promise","resolve","overrides","_getOverrides","onboarders","parsedOnboarders","_ref","getTabs","parseOnboarders","_getOnboarders","_temp4","_temp5","_temp6","_getConfigs","components","structure","hasUnsorted","getOptions","unsorted","parseComponentsFromConfigs","definitions","_parseConfigsAndCompo","parseComponents","helpParseConfigsWithCategory","getCategoryFunction","helperType","groupTypes","group","path","trackedGroups","walkConfigs","walked","visibleIf","longLabel","addGroup","nesting","push","replacement","groupType","groupExpanded","holder","setComponentGroup","addNested","addFeature","enabled","addTab","addField","fields","prettyKey","isVisible","styleClasses","required","disabled","hasAutoFocus","pattern","insert","parsedConfig","modify","remove","modifyLabel","newLabel","addPluralized","plurals","zero","one","many","getHelpers","theseConfigs","helpers","categories","parseUniqueConfigs","parseConfigsIntoCollection","getFeatures","getSettings","getTranslations","getUI","_temp7","e","reject","SourceError","error","_this","_Error","call","this","message","isUndefined","diffByStatus","diff","statusKey","status","previous","used","process","memoryUsage","Math","round","log","stack","parsedSource","opts","sortObjectAlphabetically","_callback","helpTransformResponse","sources","checkThatSourceHasConfig","option","values","mapping","mapTo","to","from","valueTo","valueFrom"],"mappings":"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"}