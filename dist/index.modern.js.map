{"version":3,"file":"index.modern.js","sources":["../src/constants/CATEGORIES.ts","../src/fetchConfigs/transformationOptions.ts","../src/sortObjectAlphabetically.ts","../src/fetchConfigs/transformToNested.ts","../src/fetchConfigs/transformResponse.ts","../src/fetchConfigs/transformToConfigValues.ts","../src/getDiff.ts","../src/logMemoryUsage.ts","../src/parseSource/parseSource.ts","../src/parseSource/parseSourceConfigs.ts"],"sourcesContent":["/* eslint-disable no-unused-vars */\nexport enum ConfigCategory {\n  Setting = `setting`,\n  Translation = `translation`,\n  UI = `ui`,\n  Feature = `feature`\n}\n\nexport enum ConfigCategoryPlurals {\n  Setting = `settings`,\n  Translation = `translations`,\n  UI = `ui`,\n  Feature = `features`\n}\n\n/* eslint-enable: no-unused-vars */\nconst CATEGORIES = {\n  [ConfigCategory.Setting]: {\n    plural: ConfigCategoryPlurals.Setting,\n    label: `Setting`,\n    labelPlural: `Settings`,\n    order: 1,\n  },\n  [ConfigCategory.Translation]: {\n    plural: ConfigCategoryPlurals.Translation,\n    label: `Translation`,\n    labelPlural: `Translations`,\n    order: 2,\n  },\n  [ConfigCategory.UI]: {\n    plural: ConfigCategoryPlurals.UI,\n    label: `UI`,\n    labelPlural: `UI`,\n    order: 3,\n  },\n  [ConfigCategory.Feature]: {\n    plural: ConfigCategoryPlurals.Feature,\n    label: `Feature`,\n    labelPlural: `Features`,\n    order: 4,\n  },\n}\n\nexport { CATEGORIES }\n","import lodash from 'lodash'\n\nconst { assign, mapValues } = lodash\n\nexport type TransformationOptions = {\n  nested: boolean,\n  categorized: boolean,\n  sort: boolean,\n}\n\nconst getTransformationOptions = (options: Partial<TransformationOptions> = {}): TransformationOptions => {\n\n  options = mapValues(options, () => true)\n\n  const opts: TransformationOptions = {\n    nested: false,\n    categorized: false,\n    sort: false, // TODO: In EDGE, we may want to be more flexible and allow a string value for `sort` to support different sorting methods\n  }\n\n  return assign(opts, options)\n}\n\nexport { getTransformationOptions }\n","import lodash from 'lodash'\n\nconst { fromPairs, sortBy, toPairs } = lodash\n\nconst sortObjectAlphabetically = object => {\n  return fromPairs(sortBy(toPairs(object), 0)) as object\n}\n\nexport { sortObjectAlphabetically }\n","import lodash from 'lodash'\n\nconst { each, setWith } = lodash\n\nconst transformToNested = object => {\n\n  const transformed = {}\n\n  each(object, (value, key) => {\n    setWith(transformed, key, value, Object)\n  })\n\n  return transformed\n}\n\nexport { transformToNested }\n","import lodash from 'lodash'\n\nimport { CATEGORIES } from '../constants'\nimport { sortObjectAlphabetically } from '../sortObjectAlphabetically'\nimport { getTransformationOptions } from './transformationOptions'\nimport { transformToNested } from './transformToNested'\n\nconst { each, get } = lodash\n\nconst helpTransformResponse = (response, callback = null) => {\n\n  const transformed = {}\n\n  each(response, (value, key) => {\n\n    if (callback) {\n\n      const {\n        key: newKey,\n        value: newValue,\n      } = callback(key, value)\n\n      if (newKey) {\n        key = newKey\n      }\n\n      if (newValue) {\n        value = newValue\n      }\n    }\n\n    transformed[key] = value\n  })\n\n  return transformed\n}\n\nconst transformResponse = (response, opts = {}, configs = null) => {\n\n  const options = getTransformationOptions(opts)\n\n  let transformed = response\n\n  if (options.sort) {\n    transformed = sortObjectAlphabetically(transformed)\n  }\n\n  if (options.categorized) {\n\n    transformed = helpTransformResponse(transformed, key => {\n\n      const config = get(configs, key)\n\n      if (config) {\n        key = `${CATEGORIES[config.category].plural}.${key}`\n      } else {\n        console.warn(`Non-existent key ${key} is not part of the config set.`)\n        key = `nonexistent.${key}`\n      }\n\n      return {\n        key,\n      }\n    })\n  }\n\n  if (options.nested) {\n    return transformToNested(transformed)\n  }\n\n  return transformed\n}\n\nexport { transformResponse }\n","import lodash from 'lodash'\n\nimport { CATEGORIES } from '../constants'\nimport { getTransformationOptions } from './transformationOptions'\nimport { transformToNested } from './transformToNested'\n\nconst { each, get, has } = lodash\n\nconst transformFromConfigsToResponse = (configs, callback = null, defaultsOnly = false) => {\n\n  const response = {}\n\n  each(configs, (config, key) => {\n    // Set inherited values\n    if (config.inherit) {\n      config.default = get(configs, config.inherit).default\n    }\n    // TODO: Figure out why configs have value properties when a configuration is saved but not published\n    let value = has(config, `value`) && !defaultsOnly ? config.value : config.default\n\n    if (callback) {\n\n      const {\n        key: newKey,\n        value: newValue,\n      } = callback(key, config)\n\n      if (newKey) {\n        key = newKey\n      }\n\n      if (newValue) {\n        value = newValue\n      }\n    }\n\n    response[key] = value\n  })\n\n  return response\n}\n\nconst transformToConfigValues = (configs, opts = {}, defaultsOnly = false) => {\n\n  const options = getTransformationOptions(opts)\n\n  const response = transformFromConfigsToResponse(configs, (key, config) => {\n\n    key = options.categorized ? `${CATEGORIES[config.category].plural}.${key}` : key\n\n    return {\n      key,\n    }\n  }, defaultsOnly)\n\n  if (options.nested) {\n    return transformToNested(response)\n  }\n\n  return response\n}\n\nexport { transformFromConfigsToResponse, transformToConfigValues }\n","import lodash from 'lodash'\n\nconst { differenceWith, each, fromPairs, has, isEqual, pickBy, toPairs } = lodash\n\nconst getDiffByStatus = (object1, object2): object => {\n  const changes = fromPairs(differenceWith(toPairs(object2), toPairs(object1), isEqual)) as object\n\n  const added = pickBy(changes, (value, key) => {\n    return !has(object1, key)\n  })\n\n  const changed = pickBy(changes, (value, key) => {\n    return has(object1, key)\n  })\n\n  const reverseChanges = fromPairs(differenceWith(toPairs(object1), toPairs(object2), isEqual)) as object\n\n  const removed = pickBy(reverseChanges, (value, key) => {\n    return !has(object2, key)\n  })\n\n  return { added: added, changed: changed, removed: removed }\n}\n\nconst getDiff = (object1, object2) => {\n  const diffByStatus = getDiffByStatus(object1, object2)\n\n  const diff = {}\n\n  each(diffByStatus, (value, statusKey) => {\n    each(diffByStatus[statusKey], (value, key) => {\n      diff[key] = {\n        value: value,\n        status: statusKey,\n        previous: has(object1, key) ? object1[key] : null,\n      }\n    })\n  })\n\n  return diff\n}\n\nexport { getDiff, getDiffByStatus }\n","const logMemoryUsage = () => {\n\n  const used = process.memoryUsage()\n\n  let message = `Memory Usage\\n`\n\n  for (let key in used) {\n    message += `${key}: ${Math.round(used[key] / 1024 / 1024 * 100) / 100} MB\\n`\n  }\n\n  console.log(message)\n}\n\nexport { logMemoryUsage }\n\n","import lodash from 'lodash'\n\nimport type { Component, ComponentOptions, Components, Config, ConfigObject, Configs, Onboarder, Onboarders, OnboarderTabs, Source, StandardizedConfigs } from '../types'\n\nconst { assign, each, get, has, includes, isObject, kebabCase, last, mapKeys, mapValues, merge, set, size, split, startCase, unset } = lodash\n\nexport type SourceConfigs = {\n  getComponents?: () => Promise<Components>,\n  getOverrides?: () => Promise<object>\n  getOnboarders?: () => Promise<Onboarder>,\n  getConfigs?: () => Promise<Configs>,\n  getLabel?: () => string | Promise<string | undefined>,\n  getName?: () => string | Promise<string | undefined>,\n  source?: string\n}\n\n// TODO: HelperFunctions is deprecated\nexport type HelperFunctions = ReturnType<typeof getHelpers>\nexport type Context = ReturnType<typeof getHelpers>\n\nexport type Definitions = {\n  [key: string]: DefinitionComponent\n}\n\n/* eslint-disable no-unused-vars */\nexport type DefinitionComponent = {\n  getConfigs?: (_: HelperFunctions) => Configs\n  getSettings?: (_: HelperFunctions) => Configs\n  getTranslations?: (_: HelperFunctions) => Configs\n  getUI?: (_: HelperFunctions) => Configs,\n  getFeatures?: (_: HelperFunctions) => Configs,\n  getOptions?: () => Component\n}\n\n/* eslint-enable no-unused-vars */\n\nconst getType = (config: Config) => {\n  if (typeof config === `object`) {\n    switch (typeof config.default) {\n      case `boolean`:\n        return `switch`\n    }\n  }\n\n  return `input`\n}\n\nconst standardizeConfig = (key: string, config: Config, skipDefaultCheck = false) => {\n\n  if (isObject(config)) {\n    if (!skipDefaultCheck && (!has(config, `default`) && !has(config, `inherit`))) {\n      throw new Error(`Config \"${key}\" is missing a \"default\" value (or \"inherit\" reference).`)\n    }\n  } else {\n    config = {\n      default: config,\n    }\n  }\n\n  return config as ConfigObject\n}\n\nconst parseConfig = (key: string, config: Config, options: Partial<ConfigObject> = {}) => {\n\n  config = standardizeConfig(key, config)\n\n  delete config.key\n\n  if (config.docLink) {\n    const docLinkText = `Documentation on this feature can be found <a href=\"${config.docLink}\">here</a>.`\n    config.hint = config.hint ? docLinkText + `<br>${config.hint}` : docLinkText\n    delete config.docLink\n  }\n\n  if (config.inherit) {\n    // TODO: It would be nice to eventually show the value of the config that is being inherited from\n    // as part of the message. (This would involve a DB lookup, so we'll save this for a later time.)\n    const inheritText = `When unchanged, inherits value from <code>${config.inherit}</code>.`\n    config.hint = config.hint ? inheritText + `<br>${config.hint}` : inheritText\n  }\n\n  return assign({\n    default: null, // This is placed here so that `default` appears as first property\n    type: getType(config),\n    label: startCase(last(split(key, `.`))),\n    category: `setting`,\n  } as ConfigObject, config, options) as ConfigObject\n}\n\nconst parseConfigs = (\n  configs: Configs,\n  options: Partial<ConfigObject> = {},\n  // eslint-disable-next-line no-unused-vars\n  callback?: (key: string, config: Config) => void,\n) => {\n\n  configs = mapKeys(configs, (config: Config, key: string) => {\n    return get(config, `key`, key)\n  })\n\n  return mapValues(configs, (config: Config, key: string) => {\n\n    callback && callback(key, config)\n\n    return parseConfig(key, config, options)\n  }) as StandardizedConfigs\n}\n\nconst parseUniqueConfigs = (set: Configs, configs: Configs, options: Partial<ConfigObject>) => {\n  return parseConfigs(configs, options, (key) => {\n    if (has(set, key)) {\n      throw new Error(`Duplicate key: \"${key}\"`)\n    }\n  })\n}\n\nconst parseConfigsIntoCollection = (set: Configs, configs: Configs, options: Partial<ComponentOptions>) => {\n  merge(set, parseUniqueConfigs(set, configs, options))\n}\n\nconst getHelpers = (components: Components, component: string, helperType: string = `setting`) => {\n\n  const groupTypes = {\n    group: {\n      path: `groups`,\n    },\n    tab: {\n      path: `tabs`,\n    },\n  }\n\n  const trackedGroups = []\n\n  const walkConfigs = (configs: Configs, callback = null) => {\n\n    const walked = {}\n\n    each(configs, (config, key) => {\n      config = standardizeConfig(key, config)\n      if (callback) {\n        const {\n          config: newConfig,\n          key: newKey,\n        } = callback(key, config)\n        walked[newKey] = newConfig\n      } else {\n        walked[key] = config\n      }\n    })\n\n    return walked\n  }\n\n  const setComponentGroup = (name: string, label: string, configs: Configs, type = `group`) => {\n\n    let path: string = groupTypes[type].path\n    let replacement: ComponentOptions = {}\n\n    each(configs, config => {\n      if (typeof config === `object` && config.group) {\n\n        // TODO: This variable should handle cases where group value is deeply nested\n        const groupExpanded = config.group\n\n        each(groupTypes, groupType => {\n          const group = get(components, [component, groupType.path, groupExpanded])\n          if (group) {\n            set(replacement, [groupType.path, groupExpanded], group)\n            unset(components, [component, groupType.path, groupExpanded])\n\n            const holder = get(components, [component, groupType.path], {})\n            if (size(holder) === 0) {\n              unset(components, [component, groupType.path])\n            }\n          }\n        })\n      }\n    })\n\n    // TODO: Need to think about this more\n    // if (has(components, [component, path, name])) {\n    //   throw new Error(`Duplicate ${type}: \"${name}\"`)\n    // }\n\n    set(components, [component, path, name], assign({\n      label: label,\n    }, replacement))\n  }\n\n  const addNested = (name: string, configs: Configs) => {\n    return walkConfigs(configs, (key: string, config: Config) => {\n\n      if (typeof config === `object`) {\n        if (config.visibleIf) {\n          config.visibleIf = `${name}.${config.visibleIf}`\n        }\n\n        config.longLabel = `${startCase(name)} ⇢ ${config.longLabel ? config.longLabel : (config.label ? config.label : startCase(key))}`\n      }\n\n      return {\n        key: `${name}.${key}`,\n        config,\n      }\n    })\n  }\n\n  const addGroup = (\n    name: string,\n    label: string,\n    configs: Configs,\n    nesting = true,\n    type = `group`,\n    /* eslint-disable-next-line no-unused-vars */\n    callback?: (_: string, _2: Config) => void,\n  ) => {\n\n    // TODO: Eventually store a running list of problems so you can see a count of the issues\n    if (includes(trackedGroups, name)) {\n      console.warn(`\"${name}\" group already exists in \"${helperType}\"`)\n    } else {\n      trackedGroups.push(name)\n    }\n\n    setComponentGroup(name, label, configs, type)\n\n    return walkConfigs(configs, (key: string, config: ConfigObject) => {\n      config.group = config.group ? `${name}.${config.group}` : name\n\n      if (callback) {\n        callback(key, config)\n      }\n\n      return {\n        key: nesting ? `${name}.${key}` : key,\n        config,\n      }\n    })\n  }\n\n  const addFeature = (name: string, label: string, configs: Configs, enabled: boolean | Config = false, nesting = true) => {\n\n    if (has(configs, `enabled`)) {\n      throw new Error(`Feature \"${name}\" should not contain a property named \"enabled\".`)\n    }\n\n    configs = assign({\n      enabled: standardizeConfig(`enabled`, enabled),\n    }, configs)\n\n    configs = addGroup(name, label, configs, nesting, `group`, (key, config) => {\n      if (key !== `enabled`) {\n        typeof config === `object` && set(config, `visibleIf`, `${name}.enabled`)\n      }\n    })\n\n    return configs as StandardizedConfigs\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  type AddFieldCallbackInnerFuncType = (key: string, config: Config) => void\n  // eslint-disable-next-line no-unused-vars\n  type RemoveFieldCallbackInnerFuncType = (key: string) => void\n  // eslint-disable-next-line no-unused-vars\n  type ModifyLabelCallbackInnerFuncType = (key: string) => void\n\n  const addField = (\n    key: string,\n    // eslint-disable-next-line no-unused-vars\n    callback?: (arg: {\n      insert: AddFieldCallbackInnerFuncType,\n      modify: AddFieldCallbackInnerFuncType,\n      remove: RemoveFieldCallbackInnerFuncType,\n      modifyLabel: ModifyLabelCallbackInnerFuncType,\n    }) => void,\n  ) => {\n\n    let fields: Configs = {}\n\n    const visibleIf = `${key}.isVisible`\n\n    const prettyKey = startCase(key)\n\n    let label = prettyKey\n\n    fields.isVisible = {\n      default: true,\n      label: `Visible`,\n      longLabel: `${prettyKey} ⇢ Visible`,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.required = {\n      default: false,\n      label: `Required`,\n      longLabel: `${prettyKey} ⇢ Required`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.disabled = {\n      default: false,\n      label: `Disabled`,\n      longLabel: `${prettyKey} ⇢ Disabled`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.hasAutoFocus = {\n      default: false,\n      label: `Autofocus`,\n      longLabel: `${prettyKey} ⇢ Autofocus`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.pattern = {\n      default: ``,\n      label: `Pattern`,\n      longLabel: `${prettyKey} ⇢ Pattern`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-12`,\n    }\n\n    if (callback) {\n\n      const insert: AddFieldCallbackInnerFuncType = (key, config) => {\n\n        if (has(fields, key)) {\n          throw new Error(`Field ${key} already exists!`)\n        }\n\n        const parsedConfig = parseConfig(key, config, {\n          visibleIf: visibleIf,\n          styleClasses: `col-md-12`,\n        })\n\n        parsedConfig.longLabel = `${prettyKey} ⇢ ${parsedConfig.label}`\n\n        fields[key] = parsedConfig\n      }\n\n      const modify: AddFieldCallbackInnerFuncType = (key, config) => {\n        merge(fields[key], standardizeConfig(key, config, true))\n      }\n\n      const remove: RemoveFieldCallbackInnerFuncType = key => {\n        delete fields[key]\n      }\n\n      const modifyLabel: ModifyLabelCallbackInnerFuncType = newLabel => {\n        label = newLabel\n      }\n\n      callback && callback({\n        insert,\n        modify,\n        remove,\n        modifyLabel,\n      })\n    }\n\n    return addGroup(key, label, fields, true)\n  }\n\n  const addTab = (label: string, configs: Configs) => {\n\n    const name = `${helperType}-${kebabCase(label)}`\n\n    return addGroup(name, label, configs, false, `tab`)\n  }\n\n  type Pluralized = {\n    zero: string,\n    one: string,\n    many: string,\n  }\n\n  const addPluralized = (name: string, plurals: Pluralized) => {\n\n    const configs = {}\n\n    if (plurals.zero) {\n      configs[`0`] = {\n        default: plurals.zero,\n        label: `Zero Case`,\n        hint: `When there are 0 items`,\n      }\n    }\n\n    if (plurals.one) {\n      configs[`1`] = {\n        default: plurals.one,\n        label: `One Case`,\n        hint: `When there is 1 item`,\n      }\n    }\n\n    if (plurals.many) {\n      configs[`other`] = {\n        default: plurals.many,\n        label: `Many Case`,\n        hint: `When there are many items`,\n      }\n    }\n\n    if (size(configs)) {\n      return addNested(name, configs)\n    }\n  }\n\n  return {\n    addNested,\n    addFeature,\n    addGroup,\n    addTab,\n    addField,\n    addPluralized,\n  }\n}\n\nconst parseConfigsAndComponents = (definitions: Definitions) => {\n\n  const configs: Configs = {}\n  const components = parseComponents(definitions)\n\n  each(definitions, (component, key) => {\n\n    const helpParseConfigsWithCategory = (getCategoryFunction, category = `setting`) => {\n\n      let options: Partial<ConfigObject> = {\n        component: key,\n      }\n\n      const helpers = getHelpers(components, key, category)\n\n      if (category) {\n        options = assign(options, {\n          category: category,\n        })\n      }\n\n      const theseConfigs = getCategoryFunction(helpers)\n      if (size(theseConfigs)) {\n\n        const categories = get(components, [key, `categories`], [])\n        categories.push(category)\n        set(components, [key, `categories`], categories)\n\n        parseConfigsIntoCollection(configs, theseConfigs, options)\n      }\n    }\n\n    const {\n      getConfigs,\n      getFeatures,\n      getSettings,\n      getTranslations,\n      getUI,\n    } = component\n\n    if (getConfigs) {\n      helpParseConfigsWithCategory(getConfigs)\n    } else {\n\n      if (getSettings) {\n        helpParseConfigsWithCategory(getSettings, `setting`)\n      }\n\n      if (getTranslations) {\n        helpParseConfigsWithCategory(getTranslations, `translation`)\n      }\n\n      if (getUI) {\n        helpParseConfigsWithCategory(getUI, `ui`)\n      }\n\n      if (getFeatures) {\n        helpParseConfigsWithCategory(getFeatures, `feature`)\n      }\n    }\n  })\n\n  return {\n    configs,\n    components,\n  }\n}\n\nconst parseComponent = (key: string, component?: ComponentOptions) => {\n  return assign({\n    label: startCase(last(split(key, `.`))),\n    order: 0,\n    toggleable: false,\n    description: null,\n    rootKey: null,\n  }, component) as ComponentOptions\n}\n\nconst parseComponents = (components: Components) => {\n  return mapValues(components, (component, key: string) => {\n    const { getOptions } = component\n\n    return parseComponent(key, getOptions ? getOptions() : null)\n  }) as Components\n}\n\nconst parseComponentsFromConfigs = (configs: Configs, structure: Components = {}) => {\n\n  // TODO: Place all these types in the \"types\" directory\n  const components: Components = {}\n\n  let hasUnsorted = false\n\n  each(configs, config => {\n    if (typeof config === `object` && has(config, `component`)) {\n      if (!has(components, config.component)) {\n\n        let options = {}\n        if (has(structure, config.component)) {\n          const { getOptions } = structure[config.component]\n          options = getOptions ? getOptions() : structure[config.component]\n        }\n\n        components[config.component] = parseComponent(config.component, options)\n      }\n    } else {\n      hasUnsorted = true\n    }\n  })\n\n  if (hasUnsorted && size(components)) {\n    components.unsorted = parseComponent(`unsorted`, {\n      order: 999,\n    })\n  }\n\n  return components\n}\n\nconst standardizeConfigs = (configs: Configs, sourceConfigs): StandardizedConfigs => {\n\n  const standardizedConfigs = {}\n\n  each(configs, config => {\n\n    if (isObject(config) && !has(config, `key`)) {\n      throw new Error(`Onboarder config missing key!`)\n    }\n\n    const key: any = isObject(config) ? config.key : config\n\n    if (!has(sourceConfigs, key)) {\n      throw new Error(`Onboarder defines key \"${key}\" which does not exist.`)\n    }\n\n    if (isObject(config)) {\n      standardizedConfigs[key] = assign({}, sourceConfigs[key], config)\n    } else {\n      standardizedConfigs[key] = assign({}, sourceConfigs[key])\n    }\n  })\n\n  return standardizedConfigs\n}\n\nconst parseOnboarderTabs = (tabs, configs): OnboarderTabs => {\n\n  const parsedOnboardersTabs = {}\n\n  each(tabs, (tab, name) => {\n\n    parsedOnboardersTabs[name] = {\n      label: tab.label ? tab.label : startCase(name),\n      configs: standardizeConfigs(tab.configs, configs),\n    }\n  })\n\n  return parsedOnboardersTabs\n}\n\nconst parseOnboarders = (onboarders, configs): Onboarders => {\n\n  const parsedOnboarders = {}\n\n  each(onboarders, ({ getLabel, getTabs }, name) => {\n\n    parsedOnboarders[name] = {\n      label: getLabel ? getLabel() : startCase(name),\n      tabs: getTabs ? parseOnboarderTabs(getTabs(), configs) : {},\n    }\n  })\n\n  return parsedOnboarders\n}\n\nconst verifyConfigs = configs => {\n\n  each(configs, (config, key) => {\n\n    // Make sure \"inherit\" value exists as a key if defined\n    if (config.inherit) {\n\n      if (!has(configs, config.inherit)) {\n        throw new Error(`Config with key \"${key}\" has inherit property defined as \"${config.inherit}\" which is not a valid key!`)\n      }\n    }\n  })\n}\n\nconst parseSource = async ({ getComponents, getConfigs, getLabel, getName, getOnboarders, getOverrides, source }: SourceConfigs) => {\n\n  const name = getName ? await getName() : source\n  const label = getLabel ? await getLabel() : startCase(name)\n\n  const options: Source = {\n    name,\n    label,\n  }\n\n  const grabComponents = getComponents ? await getComponents() : null\n\n  if (getConfigs) {\n    const configs = parseConfigs(await getConfigs())\n    const components = parseComponentsFromConfigs(configs, grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  } else {\n    let { components, configs } = parseConfigsAndComponents(grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  }\n\n  verifyConfigs(options.configs)\n\n  if (getOnboarders) {\n    options.onboarders = parseOnboarders(await getOnboarders(), options.configs)\n  }\n\n  if (getOverrides) {\n    options.overrides = await getOverrides()\n  }\n\n  return options\n}\n\nclass SourceError extends Error {\n\n  constructor(source, error) {\n    super(`${error.message} (\"${source}\" source)`)\n    this.name = `SourceError`\n  }\n}\n\nexport { parseSource, SourceError }\n","import { parseSource, SourceConfigs } from './parseSource'\n\nconst parseSourceConfigs = async (source: string, stack: SourceConfigs) => {\n\n  const parsedSource = await parseSource({\n    source,\n    ...stack,\n  })\n\n  return parsedSource.configs\n}\n\nexport { parseSourceConfigs }\n"],"names":["ConfigCategory","ConfigCategoryPlurals","CATEGORIES","Setting","plural","label","labelPlural","order","Translation","UI","Feature","assign","mapValues","lodash","getTransformationOptions","options","nested","categorized","sort","fromPairs","sortBy","toPairs","object","each","setWith","transformToNested","transformed","value","key","Object","get","transformResponse","response","opts","configs","sortObjectAlphabetically","callback","newKey","newValue","helpTransformResponse","config","category","console","warn","has","transformFromConfigsToResponse","defaultsOnly","inherit","default","transformToConfigValues","differenceWith","isEqual","pickBy","getDiffByStatus","object1","object2","changes","added","changed","reverseChanges","removed","getDiff","diffByStatus","diff","statusKey","status","previous","logMemoryUsage","used","process","memoryUsage","message","Math","round","log","includes","isObject","kebabCase","last","mapKeys","merge","set","size","split","startCase","unset","getType","skipDefaultCheck","Error","parseConfig","standardizeConfig","docLink","docLinkText","hint","inheritText","type","parseConfigs","component","toggleable","description","rootKey","standardizeConfigs","sourceConfigs","standardizedConfigs","parseOnboarderTabs","tabs","parsedOnboardersTabs","tab","name","async","getComponents","getConfigs","getLabel","getName","getOnboarders","getOverrides","source","grabComponents","components","structure","hasUnsorted","getOptions","parseComponent","unsorted","parseComponentsFromConfigs","definitions","parseComponents","helpParseConfigsWithCategory","getCategoryFunction","helpers","helperType","groupTypes","group","path","trackedGroups","walkConfigs","walked","newConfig","addNested","visibleIf","longLabel","addGroup","nesting","push","replacement","groupExpanded","groupType","holder","setComponentGroup","addFeature","enabled","addTab","addField","fields","prettyKey","isVisible","styleClasses","required","disabled","hasAutoFocus","pattern","insert","parsedConfig","modify","remove","modifyLabel","newLabel","addPluralized","plurals","zero","one","many","getHelpers","theseConfigs","categories","parseUniqueConfigs","parseConfigsIntoCollection","getFeatures","getSettings","getTranslations","getUI","parseConfigsAndComponents","onboarders","parsedOnboarders","getTabs","parseOnboarders","overrides","SourceError","constructor","error","super","this","parseSourceConfigs","stack","parseSource","_extends"],"mappings":"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"}