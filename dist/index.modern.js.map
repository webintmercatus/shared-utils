{"version":3,"file":"index.modern.js","sources":["../src/constants/CATEGORIES.ts","../src/fetchConfigs/transformationOptions.ts","../src/fetchConfigs/transformToNested.ts","../src/fetchConfigs/transformResponse.ts","../src/fetchConfigs/transformToConfigValues.ts","../src/parseSource/parseSource.ts","../src/parseSource/parseSourceConfigs.ts"],"sourcesContent":["enum ConfigCategory {\n  Settings = `settings`,\n  Translations = `translations`,\n  UI = `ui`\n}\n\nconst CATEGORIES = {\n  setting: {\n    plural: ConfigCategory.Settings,\n    label: `Setting`,\n    labelPlural: `Settings`,\n    order: 1,\n  },\n  translation: {\n    plural: ConfigCategory.Translations,\n    label: `Translation`,\n    labelPlural: `Translations`,\n    order: 2,\n  },\n  ui: {\n    plural: ConfigCategory.UI,\n    label: `UI`,\n    labelPlural: `UI`,\n    order: 3,\n  },\n  ORGANIZATION_SETTINGS: {\n    plural: `ORGANIZATION_SETTINGS`,\n    label: `Organization`,\n    labelPlural: `Organization`,\n    order: 1,\n  },\n  TRANSLATION_SETTINGS: {\n    plural: `TRANSLATION_SETTINGS`,\n    label: `Translation`,\n    labelPlural: `Translations`,\n    order: 2,\n  },\n  FEATURE_SETTINGS: {\n    plural: `FEATURE_SETTINGS`,\n    label: `Feature`,\n    labelPlural: `Features`,\n    order: 3,\n  },\n}\n\nexport { CATEGORIES, ConfigCategory }\n","import lodash from 'lodash'\n\nconst { assign, mapValues } = lodash\n\nexport type TransformationOptions = {\n  nested: boolean,\n  categorized: boolean,\n}\n\nconst getTransformationOptions = (options: Partial<TransformationOptions> = {}): TransformationOptions => {\n\n  options = mapValues(options, () => true)\n\n  const opts: TransformationOptions = {\n    nested: false,\n    categorized: false,\n  }\n\n  return assign(opts, options)\n}\n\nexport { getTransformationOptions }\n","import lodash from 'lodash'\n\nconst { each, setWith } = lodash\n\nconst transformToNested = object => {\n\n  const transformed = {}\n\n  each(object, (value, key) => {\n    setWith(transformed, key, value, Object)\n  })\n\n  return transformed\n}\n\nexport { transformToNested }\n","import lodash from 'lodash'\n\nimport { getTransformationOptions } from './transformationOptions'\nimport { transformToNested } from './transformToNested'\n\nconst { each, get } = lodash\n\nconst helpTransformResponse = (response, callback = null) => {\n\n  const transformed = {}\n\n  each(response, (value, key) => {\n\n    if (callback) {\n\n      const {\n        key: newKey,\n        value: newValue,\n      } = callback(key, value)\n\n      if (newKey) {\n        key = newKey\n      }\n\n      if (newValue) {\n        value = newValue\n      }\n    }\n\n    transformed[key] = value\n  })\n\n  return transformed\n}\n\nconst transformResponse = (response, opts = {}, configs = null) => {\n\n  const options = getTransformationOptions(opts)\n\n  const transformed = helpTransformResponse(response, key => {\n\n    if (options.categorized) {\n\n      const config = get(configs, key)\n\n      if (config) {\n        key = `${config.category}.${key}`\n      }\n    }\n\n    return {\n      key,\n    }\n  })\n\n  if (options.nested) {\n    return transformToNested(transformed)\n  }\n\n  return transformed\n}\n\nexport { transformResponse }\n","import lodash from 'lodash'\n\nimport { CATEGORIES } from '../constants'\nimport { getTransformationOptions } from './transformationOptions'\nimport { transformToNested } from './transformToNested'\n\nconst { each, has } = lodash\n\nconst transformFromConfigsToResponse = (configs, callback = null) => {\n\n  const response = {}\n\n  each(configs, (config, key) => {\n\n    let value = has(config, `value`) ? config.value : config.default\n\n    if (callback) {\n\n      const {\n        key: newKey,\n        value: newValue,\n      } = callback(key, config)\n\n      if (newKey) {\n        key = newKey\n      }\n\n      if (newValue) {\n        value = newValue\n      }\n    }\n\n    response[key] = value\n  })\n\n  return response\n}\n\nconst transformToConfigValues = (configs, opts = {}) => {\n\n  const options = getTransformationOptions(opts)\n\n  const response = transformFromConfigsToResponse(configs, (key, config) => {\n\n    key = options.categorized ? `${CATEGORIES[config.category].plural}.${key}` : key\n\n    return {\n      key,\n    }\n  })\n\n  if (options.nested) {\n    return transformToNested(response)\n  }\n\n  return response\n}\n\nexport { transformToConfigValues }\n","import lodash from 'lodash'\n\nimport type { Component, ComponentOptions, Components, Config, ConfigObject, Configs, Source, StandardizedConfigs } from '../types'\n\nconst { assign, each, get, has, isObject, kebabCase, last, mapKeys, mapValues, merge, set, size, split, startCase, unset } = lodash\n\nexport type SourceConfigs = {\n  getComponents?: () => Promise<Components>,\n  getConfigs?: () => Promise<Configs>,\n  getLabel?: () => string | Promise<string | undefined>,\n  getName?: () => string | Promise<string | undefined>,\n  source?: string\n}\n\nexport type HelperFunctions = ReturnType<typeof getHelpers>\n\nexport type Definitions = {\n  [key: string]: DefinitionComponent\n}\n\n/* eslint-disable no-unused-vars */\nexport type DefinitionComponent = {\n  getConfigs?: (_: HelperFunctions) => Configs\n  getSettings?: (_: HelperFunctions) => Configs\n  getTranslations?: (_: HelperFunctions) => Configs\n  getUI?: (_: HelperFunctions) => Configs,\n  getOptions?: () => Component\n}\n\n/* eslint-enable no-unused-vars */\n\nconst getType = (config: Config) => {\n  if (typeof config === `object`) {\n    switch (typeof config.default) {\n      case `boolean`:\n        return `switch`\n    }\n  }\n\n  return `input`\n}\n\nconst standardizeConfig = (key: string, config: Config, skipDefaultCheck = false) => {\n\n  if (isObject(config)) {\n    if (!skipDefaultCheck && !has(config, `default`)) {\n      throw new Error(`Config \"${key}\" is missing a \"default\" value.`)\n    }\n  } else {\n    config = {\n      default: config,\n    }\n  }\n\n  return config as ConfigObject\n}\n\nconst parseConfig = (key: string, config: Config, options: Partial<ConfigObject> = {}) => {\n\n  config = standardizeConfig(key, config)\n\n  delete config.key\n\n  if (config.docLink) {\n    const docLinkText = `Documentation on this feature can be found <a href=\"${config.docLink}\">here</a>.`\n    config.hint = config.hint ? docLinkText + `<br>${config.hint}` : docLinkText\n    delete config.docLink\n  }\n\n  return assign({\n    default: null, // This is placed here so that `default` appears as first property\n    type: getType(config),\n    label: startCase(last(split(key, `.`))),\n    category: `setting`,\n  } as ConfigObject, config, options) as ConfigObject\n}\n\nconst parseConfigs = (\n  configs: Configs,\n  options: Partial<ConfigObject> = {},\n  // eslint-disable-next-line no-unused-vars\n  callback?: (key: string, config: Config) => void,\n) => {\n\n  configs = mapKeys(configs, (config: Config, key: string) => {\n    return lodash.get(config, `key`, key)\n  })\n\n  return mapValues(configs, (config: Config, key: string) => {\n\n    callback && callback(key, config)\n\n    return parseConfig(key, config, options)\n  }) as StandardizedConfigs\n}\n\nconst parseUniqueConfigs = (set: Configs, configs: Configs, options: Partial<ConfigObject>) => {\n  return parseConfigs(configs, options, (key) => {\n    if (has(set, key)) {\n      throw new Error(`Duplicate key: \"${key}\"`)\n    }\n  })\n}\n\nconst parseConfigsIntoCollection = (set: Configs, configs: Configs, options: Partial<ComponentOptions>) => {\n  merge(set, parseUniqueConfigs(set, configs, options))\n}\n\nconst getHelpers = (components: Components, component: string) => {\n\n  const groupTypes = {\n    group: {\n      path: `groups`,\n    },\n    tab: {\n      path: `tabs`,\n    },\n  }\n\n  const walkConfigs = (configs: Configs, callback = null) => {\n\n    const walked: StandardizedConfigs = {}\n\n    each(configs, (config, key) => {\n      config = standardizeConfig(key, config)\n      if (callback) {\n        const {\n          config: newConfig,\n          key: newKey,\n        } = callback(key, config)\n        walked[newKey] = newConfig\n      } else {\n        walked[key] = config\n      }\n    })\n\n    return walked\n  }\n\n  const setComponentGroup = (name: string, label: string, configs: Configs, type = `group`) => {\n\n    let path: string = groupTypes[type].path\n    let replacement: ComponentOptions = {}\n\n    each(configs, config => {\n      if (typeof config === `object` && config.group) {\n\n        // TODO: This variable should handle cases where group value is deeply nested\n        const groupExpanded = config.group\n\n        each(groupTypes, groupType => {\n          const group = get(components, [component, groupType.path, groupExpanded])\n          if (group) {\n            set(replacement, [groupType.path, groupExpanded], group)\n            unset(components, [component, groupType.path, groupExpanded])\n\n            const holder = get(components, [component, groupType.path], {})\n            if (size(holder) === 0) {\n              unset(components, [component, groupType.path])\n            }\n          }\n        })\n      }\n    })\n\n    // TODO: Need to think about this more\n    // if (has(components, [component, path, name])) {\n    //   throw new Error(`Duplicate ${type}: \"${name}\"`)\n    // }\n\n    set(components, [component, path, name], assign({\n      label: label,\n    }, replacement))\n  }\n\n  const addNested = (name: string, configs: Configs) => {\n    return walkConfigs(configs, (key: string, config: Config) => {\n\n      if (typeof config === `object`) {\n        if (config.visibleIf) {\n          config.visibleIf = `${name}.${config.visibleIf}`\n        }\n\n        config.longLabel = `${startCase(name)} ⇢ ${config.longLabel ? config.longLabel : (config.label ? config.label : startCase(key))}`\n      }\n\n      return {\n        key: `${name}.${key}`,\n        config,\n      }\n    })\n  }\n\n  const addGroup = (\n    name: string,\n    label: string,\n    configs: Configs,\n    nesting = true,\n    type = `group`,\n    /* eslint-disable-next-line no-unused-vars */\n    callback?: (_: string, _2: Config) => void,\n  ) => {\n    setComponentGroup(name, label, configs, type)\n\n    return walkConfigs(configs, (key: string, config: ConfigObject) => {\n      config.group = config.group ? `${name}.${config.group}` : name\n\n      if (callback) {\n        callback(key, config)\n      }\n\n      return {\n        key: nesting ? `${name}.${key}` : key,\n        config,\n      }\n    })\n  }\n\n  const addFeature = (name: string, label: string, configs: Configs, enabled = false, nesting = true) => {\n\n    if (has(configs, `enabled`)) {\n      throw new Error(`Feature \"${name}\" should not contain a property named \"enabled\".`)\n    }\n\n    configs = assign({\n      enabled: standardizeConfig(`enabled`, enabled),\n    }, configs)\n\n    configs = addGroup(name, label, configs, nesting, `group`, (key, config) => {\n      if (key !== `enabled`) {\n        typeof config === `object` && lodash.set(config, `visibleIf`, `${name}.enabled`)\n      }\n    })\n\n    return configs as StandardizedConfigs\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  type AddFieldCallbackInnerFuncType = (key: string, config: Config) => void\n\n  const addField = (\n    key: string,\n    // eslint-disable-next-line no-unused-vars\n    callback?: (arg: { insert: AddFieldCallbackInnerFuncType, modify: AddFieldCallbackInnerFuncType }) => void,\n  ) => {\n\n    let fields: Configs = {}\n\n    const visibleIf = `${key}.isVisible`\n\n    const prettyKey = startCase(key)\n\n    fields.isVisible = {\n      default: true,\n      label: `Visible`,\n      longLabel: `${prettyKey} ⇢ Visible`,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.required = {\n      default: false,\n      label: `Required`,\n      longLabel: `${prettyKey} ⇢ Required`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.disabled = {\n      default: false,\n      label: `Disabled`,\n      longLabel: `${prettyKey} ⇢ Disabled`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.readonly = {\n      default: false,\n      label: `Readonly`,\n      longLabel: `${prettyKey} ⇢ Readonly`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.hasAutoFocus = {\n      default: false,\n      label: `Autofocus`,\n      longLabel: `${prettyKey} ⇢ Autofocus`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.pattern = {\n      default: ``,\n      label: `Pattern`,\n      longLabel: `${prettyKey} ⇢ Pattern`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-12`,\n    }\n\n    if (callback) {\n\n      const insert: AddFieldCallbackInnerFuncType = (key, config) => {\n\n        if (has(fields, key)) {\n          throw new Error(`Field ${key} already exists!`)\n        }\n\n        const parsedConfig = parseConfig(key, config, {\n          visibleIf: visibleIf,\n          styleClasses: `col-md-12`,\n        })\n\n        parsedConfig.longLabel = `${prettyKey} ⇢ ${parsedConfig.label}`\n\n        fields[key] = parsedConfig\n      }\n\n      const modify: AddFieldCallbackInnerFuncType = (key, config) => {\n        merge(fields[key], standardizeConfig(key, config, true))\n      }\n\n      callback && callback({\n        insert,\n        modify,\n      })\n    }\n\n    return addGroup(key, startCase(key), fields, true)\n  }\n\n  const addTab = (label: string, configs: Configs) => {\n\n    const name = kebabCase(label)\n\n    return addGroup(name, label, configs, false, `tab`)\n  }\n\n  return {\n    addNested,\n    addFeature,\n    addGroup,\n    addTab,\n    addField,\n  }\n}\n\nconst parseConfigsAndComponents = (definitions: Definitions) => {\n\n  const configs: Configs = {}\n  const components = parseComponents(definitions)\n\n  each(definitions, (component, key) => {\n\n    const {\n      getConfigs,\n      getSettings,\n      getTranslations,\n      getUI,\n    } = component\n\n    const options: Partial<ConfigObject> = {\n      component: key,\n    }\n\n    const helpers = getHelpers(components, key)\n\n    if (getConfigs) {\n      parseConfigsIntoCollection(configs, getConfigs(helpers), options)\n    } else {\n\n      if (getSettings) {\n        parseConfigsIntoCollection(configs, getSettings(helpers), assign(options, {\n          category: `setting`,\n        }))\n      }\n\n      if (getTranslations) {\n        parseConfigsIntoCollection(configs, getTranslations(helpers), assign(options, {\n          category: `translation`,\n        }))\n      }\n\n      if (getUI) {\n        parseConfigsIntoCollection(configs, getUI(helpers), assign(options, {\n          category: `ui`,\n        }))\n      }\n    }\n  })\n\n  return {\n    configs,\n    components,\n  }\n}\n\nconst parseComponent = (key: string, component?: ComponentOptions) => {\n  return assign({\n    label: startCase(last(split(key, `.`))),\n    order: 0,\n    toggleable: false,\n    description: null,\n    rootKey: null,\n  }, component) as ComponentOptions\n}\n\nconst parseComponents = (components: Components) => {\n  return mapValues(components, (component, key: string) => {\n    const { getOptions } = component\n\n    return parseComponent(key, getOptions ? getOptions() : null)\n  }) as Components\n}\n\nconst parseComponentsFromConfigs = (configs: Configs, structure: Components = {}) => {\n\n  // TODO: Place all these types in the \"types\" directory\n  const components: Components = {}\n\n  let hasUnsorted = false\n\n  each(configs, config => {\n    if (typeof config === `object` && has(config, `component`)) {\n      if (!has(components, config.component)) {\n\n        let options = {}\n        if (has(structure, config.component)) {\n          const { getOptions } = structure[config.component]\n          options = getOptions ? getOptions() : structure[config.component]\n        }\n\n        components[config.component] = parseComponent(config.component, options)\n      }\n    } else {\n      hasUnsorted = true\n    }\n  })\n\n  if (hasUnsorted && size(components)) {\n    components.unsorted = parseComponent(`unsorted`, {\n      order: 999,\n    })\n  }\n\n  return components\n}\n\nconst parseSource = async ({ getComponents, getConfigs, getLabel, getName, source }: SourceConfigs) => {\n\n  const name = getName ? await getName() : source\n  const label = getLabel ? await getLabel() : startCase(name)\n\n  const options: Source = {\n    name,\n    label,\n  }\n\n  const grabComponents = getComponents ? await getComponents() : null\n\n  if (getConfigs) {\n    const config = parseConfigs(await getConfigs())\n    const components = parseComponentsFromConfigs(config, grabComponents)\n    merge(options, {\n      config,\n      components,\n    })\n  } else {\n    const { components, configs } = parseConfigsAndComponents(grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  }\n\n  return options\n}\n\nclass SourceError extends Error {\n\n  constructor(source, error) {\n    super(`${error.message} (\"${source}\" source)`)\n    this.name = `SourceError`\n  }\n}\n\nexport { parseSource, SourceError }\n","import { parseSource, SourceConfigs } from '../'\n\nconst parseSourceConfigs = async (source: string, stack: SourceConfigs) => {\n\n  const parsedSource = await parseSource({\n    source,\n    ...stack,\n  })\n\n  return parsedSource.configs\n}\n\nexport { parseSourceConfigs }\n"],"names":["ConfigCategory","CATEGORIES","setting","plural","Settings","label","labelPlural","order","translation","Translations","ui","UI","ORGANIZATION_SETTINGS","TRANSLATION_SETTINGS","FEATURE_SETTINGS","assign","mapValues","lodash","getTransformationOptions","options","nested","categorized","each","setWith","transformToNested","object","transformed","value","key","Object","get","transformResponse","response","opts","configs","callback","newKey","newValue","helpTransformResponse","config","category","has","transformToConfigValues","default","transformFromConfigsToResponse","isObject","kebabCase","last","mapKeys","merge","set","size","split","startCase","unset","getType","standardizeConfig","skipDefaultCheck","Error","parseConfig","docLink","docLinkText","hint","type","parseConfigs","parseConfigsIntoCollection","parseUniqueConfigs","parseComponent","component","toggleable","description","rootKey","parseSource","async","getComponents","getConfigs","getLabel","getName","source","name","grabComponents","components","structure","hasUnsorted","getOptions","unsorted","parseComponentsFromConfigs","definitions","parseComponents","getSettings","getTranslations","getUI","helpers","groupTypes","group","path","tab","walkConfigs","walked","newConfig","addGroup","nesting","replacement","groupExpanded","groupType","holder","setComponentGroup","addNested","visibleIf","longLabel","addFeature","enabled","addTab","addField","fields","prettyKey","isVisible","styleClasses","required","disabled","readonly","hasAutoFocus","pattern","insert","parsedConfig","modify","getHelpers","parseConfigsAndComponents","SourceError","constructor","error","super","message","this","parseSourceConfigs","stack","_extends"],"mappings":"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"}