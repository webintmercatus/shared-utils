import e from"lodash";var t,n;!function(e){e.Setting="setting",e.Translation="translation",e.UI="ui",e.Feature="feature"}(t||(t={})),function(e){e.Setting="settings",e.Translation="translations",e.UI="ui",e.Feature="features"}(n||(n={}));const a={[t.Setting]:{plural:n.Setting,label:"Setting",labelPlural:"Settings",order:1},[t.Translation]:{plural:n.Translation,label:"Translation",labelPlural:"Translations",order:2},[t.UI]:{plural:n.UI,label:"UI",labelPlural:"UI",order:3},[t.Feature]:{plural:n.Feature,label:"Feature",labelPlural:"Features",order:4}},{assign:l,mapValues:o}=e,s=(e={})=>(e=o(e,()=>!0),l({nested:!1,categorized:!1},e)),{each:r,setWith:i}=e,u=e=>{const t={};return r(e,(e,n)=>{i(t,n,e,Object)}),t},{each:c,get:b}=e,d=(e,t={},n=null)=>{const l=s(t),o=((e,t=null)=>{const n={};return c(e,(e,a)=>{if(t){const{key:n,value:l}=t(a,e);n&&(a=n),l&&(e=l)}n[a]=e}),n})(e,e=>{if(l.categorized){const t=b(n,e);t&&(e=`${a[t.category].plural}.${e}`)}return{key:e}});return l.nested?u(o):o},{each:f,has:g}=e,p=(e,t={})=>{const n=s(t),l=((e,t=null)=>{const n={};return f(e,(e,a)=>{let l=g(e,"value")?e.value:e.default;if(t){const{key:n,value:o}=t(a,e);n&&(a=n),o&&(l=o)}n[a]=l}),n})(e,(e,t)=>({key:e=n.categorized?`${a[t.category].plural}.${e}`:e}));return n.nested?u(l):l};function y(){return y=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},y.apply(this,arguments)}const{each:h,isBoolean:m,isObject:$,last:w,split:v,startsWith:k,trimEnd:I}=e,C=e=>{const t={},n=((e,t="")=>{const n=function e(t,n){if(!t||"object"!=typeof t)return[{[n]:t}];const a=n?Array.isArray(t)?n:`${n}.`:"";return Object.keys(t).flatMap(n=>e(t[n],Array.isArray(t)?`${a}[${n}]`:`${a}${n}`)).reduce((e,t)=>y({},e,t),[])}(e,t),a={};return h(n,(e,t)=>{const n=v(t,"."),l=w(n);k(l,"#")?"#value"===l&&(a[I(t,".#value")]=e):a[t]=e}),a})(e);return h(n,(e,n)=>{let a=e;$(e)&&(a=e["#value"]);const l={default:a};m(a)&&(l.type="switch"),t[n]=l}),t},{assign:L,each:O,get:j,has:F,includes:E,isObject:T,kebabCase:P,last:S,mapKeys:z,mapValues:A,merge:U,set:V,size:x,split:W,startCase:D,unset:R}=e,q=e=>"object"==typeof e&&"boolean"==typeof e.default?"switch":"input",K=(e,t,n=!1)=>{if(T(t)){if(!n&&!F(t,"default"))throw new Error(`Config "${e}" is missing a "default" value.`)}else t={default:t};return t},M=(e,t,n={})=>{if(delete(t=K(e,t)).key,t.docLink){const e=`Documentation on this feature can be found <a href="${t.docLink}">here</a>.`;t.hint=t.hint?e+`<br>${t.hint}`:e,delete t.docLink}return L({default:null,type:q(t),label:D(S(W(e,"."))),category:"setting"},t,n)},N=(t,n={},a)=>(t=z(t,(t,n)=>e.get(t,"key",n)),A(t,(e,t)=>(a&&a(t,e),M(t,e,n)))),B=(e,t)=>L({label:D(S(W(e,"."))),order:0,toggleable:!1,description:null,rootKey:null},t),G=(e,t)=>{const n={};return O(e,e=>{if(T(e)&&!F(e,"key"))throw new Error("Onboarder config missing key!");const a=T(e)?e.key:e;if(!F(t,a))throw new Error(`Onboarder defines key "${a}" which does not exist.`);n[a]=T(e)?L({},t[a],e):L({},t[a])}),n},Z=(e,t)=>{const n={};return O(e,(e,a)=>{n[a]={label:e.label?e.label:D(a),configs:G(e.configs,t)}}),n},H=async({getComponents:t,getConfigs:n,getLabel:a,getName:l,getOnboarders:o,source:s})=>{const r=l?await l():s,i={name:r,label:a?await a():D(r)},u=t?await t():null;if(n){const e=N(await n()),t=((e,t={})=>{const n={};let a=!1;return O(e,e=>{if("object"==typeof e&&F(e,"component")){if(!F(n,e.component)){let a={};if(F(t,e.component)){const{getOptions:n}=t[e.component];a=n?n():t[e.component]}n[e.component]=B(e.component,a)}}else a=!0}),a&&x(n)&&(n.unsorted=B("unsorted",{order:999})),n})(e,u);U(i,{configs:e,components:t})}else{let{components:t,configs:n}=(t=>{const n={},a=(e=>A(e,(e,t)=>{const{getOptions:n}=e;return B(t,n?n():null)}))(t);return O(t,(t,l)=>{const o=(t,o="setting")=>{let s={component:l};const r=((t,n,a="setting")=>{const l={group:{path:"groups"},tab:{path:"tabs"}},o=[],s=(e,t=null)=>{const n={};return O(e,(e,a)=>{if(e=K(a,e),t){const{config:l,key:o}=t(a,e);n[o]=l}else n[a]=e}),n},r=(e,t)=>s(t,(t,n)=>("object"==typeof n&&(n.visibleIf&&(n.visibleIf=`${e}.${n.visibleIf}`),n.longLabel=`${D(e)} ⇢ ${n.longLabel?n.longLabel:n.label?n.label:D(t)}`),{key:`${e}.${t}`,config:n})),i=(e,r,i,u=!0,c="group",b)=>(E(o,e)?console.warn(`"${e}" group already exists in "${a}"`):o.push(e),((e,a,o,s="group")=>{let r=l[s].path,i={};O(o,e=>{if("object"==typeof e&&e.group){const a=e.group;O(l,e=>{const l=j(t,[n,e.path,a]);if(l){V(i,[e.path,a],l),R(t,[n,e.path,a]);const o=j(t,[n,e.path],{});0===x(o)&&R(t,[n,e.path])}})}}),V(t,[n,r,e],L({label:a},i))})(e,r,i,c),s(i,(t,n)=>(n.group=n.group?`${e}.${n.group}`:e,b&&b(t,n),{key:u?`${e}.${t}`:t,config:n})));return{addNested:r,addFeature:(t,n,a,l=!1,o=!0)=>{if(F(a,"enabled"))throw new Error(`Feature "${t}" should not contain a property named "enabled".`);return a=L({enabled:K("enabled",l)},a),i(t,n,a,o,"group",(n,a)=>{"enabled"!==n&&"object"==typeof a&&e.set(a,"visibleIf",`${t}.enabled`)})},addGroup:i,addTab:(e,t)=>{const n=`${a}-${P(e)}`;return i(n,e,t,!1,"tab")},addField:(e,t)=>{let n={};const a=`${e}.isVisible`,l=D(e);let o=l;if(n.isVisible={default:!0,label:"Visible",longLabel:`${l} ⇢ Visible`,styleClasses:"col-md-2"},n.required={default:!1,label:"Required",longLabel:`${l} ⇢ Required`,visibleIf:a,styleClasses:"col-md-2"},n.disabled={default:!1,label:"Disabled",longLabel:`${l} ⇢ Disabled`,visibleIf:a,styleClasses:"col-md-2"},n.readonly={default:!1,label:"Readonly",longLabel:`${l} ⇢ Readonly`,visibleIf:a,styleClasses:"col-md-2"},n.hasAutoFocus={default:!1,label:"Autofocus",longLabel:`${l} ⇢ Autofocus`,visibleIf:a,styleClasses:"col-md-2"},n.pattern={default:"",label:"Pattern",longLabel:`${l} ⇢ Pattern`,visibleIf:a,styleClasses:"col-md-12"},t){const e=(e,t)=>{if(F(n,e))throw new Error(`Field ${e} already exists!`);const o=M(e,t,{visibleIf:a,styleClasses:"col-md-12"});o.longLabel=`${l} ⇢ ${o.label}`,n[e]=o},s=(e,t)=>{U(n[e],K(e,t,!0))},r=e=>{o=e};t&&t({insert:e,modify:s,modifyLabel:r})}return i(e,o,n,!0)},addPluralized:(e,t)=>{const n={};if(t.zero&&(n[0]={default:t.zero,label:"Zero Case",hint:"When there are 0 items"}),t.one&&(n[1]={default:t.one,label:"One Case",hint:"When there is 1 item"}),t.many&&(n.other={default:t.many,label:"Many Case",hint:"When there are many items"}),x(n))return r(e,n)}}})(a,l,o);o&&(s=L(s,{category:o}));const i=t(r);if(x(i)){const e=j(a,[l,"categories"],[]);e.push(o),V(a,[l,"categories"],e),((e,t,n)=>{U(e,((e,t,n)=>N(t,n,t=>{if(F(e,t))throw new Error(`Duplicate key: "${t}"`)}))(e,t,n))})(n,i,s)}},{getConfigs:s,getFeatures:r,getSettings:i,getTranslations:u,getUI:c}=t;s?o(s):(i&&o(i,"setting"),u&&o(u,"translation"),c&&o(c,"ui"),r&&o(r,"feature"))}),{configs:n,components:a}})(u);U(i,{configs:n,components:t})}return o&&(i.onboarders=((e,t)=>{const n={};return O(e,({getLabel:e,getTabs:a},l)=>{n[l]={label:e?e():D(l),tabs:a?Z(a(),t):{}}}),n})(await o(),i.configs)),i};class J extends Error{constructor(e,t){super(`${t.message} ("${e}" source)`),this.name="SourceError"}}const Q=async(e,t)=>(await H(y({source:e},t))).configs;export{a as CATEGORIES,t as ConfigCategory,n as ConfigCategoryPlurals,J as SourceError,C as createConfigsFromJson,s as getTransformationOptions,H as parseSource,Q as parseSourceConfigs,d as transformResponse,p as transformToConfigValues,u as transformToNested};
//# sourceMappingURL=index.modern.js.map
